export const projects = [
  {
    "title": "Dropship Order Intake",
    "description": "This project automates the process of fetching order files from an FTP server, validating them, extracting purchase order details, and storing them in a database.",
    "files": [
      {
        "filename": "README.md",
        "code": `# Dropship Order Processing System

This project automates the process of fetching order files from an FTP server, validating them, extracting purchase order details, and storing them in a database.

## Features
- Connects to an FTP server to download order files.
- Validates order files using predefined rules.
- Parses and standardizes order data.
- Stores order details in an Azure SQL database.
- Sends email notifications for errors or important updates.
- Moves processed files to appropriate FTP folders.

## Project Structure
project_root/ ├── config.py # Configuration file for database & FTP credentials 
              ├── dropship_db.py # Handles database interactions 
              ├── email_helper.py # Sends email notifications 
              ├── ftp.py # Manages FTP file transfers 
              ├── invalid_file_checker.py # Validates order files 
              ├── main.py # Main script orchestrating the process 
              ├── xlsx_parser.py # Parses Excel/CSV order files

bash
Copy
Edit

## Installation & Setup

### 1. Clone the Repository
git clone https://github.com/your-repo/dropship-processing.git
cd dropship-processing

### 2. Install Dependencies
Ensure you have Python 3 installed, then install dependencies:
pip install -r requirements.txt

### 3. Configure the System
Modify config.py with your database and FTP credentials.

## Example database configuration:
db_config = {
    "ExampleDb": {
        "server": "your.database.windows.net",
        "database": "YourDB",
        "username": "your_user",
        "password": "your_password",
        "driver": "{ODBC Driver 17 for SQL Server}",
    },
}

## Example email configuration:

SENDER_EMAIL = "your_email@example.com"
SENDER_PASSWORD = "your_email_password"

## Usage

Run the main script to start the process:
python main.py

## How It Works

- The script connects to an FTP server and downloads order files.
- It checks for duplicates, correct formatting, and required fields.
- Valid orders are stored in an Azure SQL database.
- Processed files are moved to respective FTP folders.
- If an issue occurs, an email notification is sent.

## Tech Stack

- Python 3
- Azure SQL Database (via pyodbc)
- FTP File Handling (ftplib)
- Email Notifications (smtplib)
- Pandas for data parsing
- TQDM for progress tracking

## Troubleshooting

- If you encounter a database connection issue, verify that ODBC Driver 17 is installed.
- If emails fail to send, ensure you have enabled "Less Secure Apps" in your email settings.

`
      },
      {
        "filename": "main.py",
        "code": "from email_helper import send_email\nfrom ftp import FTPManager\nfrom example_db import ExampleDb\nfrom invalid_file_checker import InvalidFileChecker\nfrom xlsx_parser import XlsxParser\nfrom tqdm import tqdm\nimport traceback\nimport os\n\n\ndef main():\n    try:\n        d_db = ExampleDb()\n        ftp = FTPManager()\n\n        # Getting the dropshipper data\n        dropshipper_data = d_db.load_dropship_data()\n        international_accounts = d_db.get_international_accounts()\n        excluded_shipping_states = d_db.load_excluded_shipping_states()\n\n        parser = XlsxParser(dropshipper_data, d_db)\n\n        # Placeholders\n        all_valid_files = {}\n        all_invalid_files = {}\n        all_order_objs = {}\n        dropshipper_names = []\n\n        for dropshipper in dropshipper_data.values():\n            dropshipper_id = dropshipper[\"id\"]\n            dropshipper_name = dropshipper[\"name\"]\n            dropshipper_names.append(dropshipper_name)\n            ftp_folder_name = dropshipper[\"ftp_folder_name\"]\n            header_template = dropshipper[\"headers\"]\n\n            # Downloading the files from the FTP server\n            new_orders_file_path = ftp.download_files(ftp_folder_name)\n\n            # If there are no new orders, skip to the next dropshipper\n            if not new_orders_file_path:\n                continue\n            elif not os.listdir(new_orders_file_path):\n                os.rmdir(new_orders_file_path)\n                continue\n\n            # Checking if the files are valid\n            checker = InvalidFileChecker(d_db, parser)\n            valid_files, invalid_files = checker.validate_files(\n                new_orders_file_path, header_template\n            )\n\n            # Adding the files to dictionaries using the dropshipper_id as the key\n            if valid_files:\n                # NOTE: Turn off to not store the file names in the database to check for duplicates\n                for path in tqdm(\n                    valid_files, desc=f\"Storing file names for {ftp_folder_name}\"\n                ):\n                    file_name, pos = parser.data_extractor(\n                        path, dropshipper[\"po_header_name\"]\n                    )\n                d_db.store_file_names(file_name, pos, dropshipper_id, path)\n                all_valid_files[dropshipper_id] = valid_files\n\n            if invalid_files:\n                all_invalid_files[dropshipper_name] = invalid_files\n\n        # Parsing the files\n        if all_valid_files:\n            po_objs, unparsed_skus = parser.file_parser(all_valid_files)\n            all_order_objs.update(po_objs)\n\n        # Checking the allowed skus\n        all_order_objs = parser.check_allowed_skus(all_order_objs, dropshipper_data)\n\n        # If there are no new orders, skip the rest of the code\n        if not all_order_objs:\n            if all_valid_files:\n                ftp.moving_files(all_valid_files, \"order_logs\")\n            if all_invalid_files:\n                ftp.moving_files(all_invalid_files, \"error_logs\", remove_from_tmp=True)\n            return\n\n        # Checking the shipping states\n        unable_to_ship, shipable_orders_objs = parser.check_shipping_states(\n            all_order_objs, excluded_shipping_states, international_accounts\n        )\n\n        # Sending an email with the orders that can't be shipped\n        if unable_to_ship:\n            send_email(\n                \"Orders Unable to Ship\",\n                f\"Orders unable to ship: {unable_to_ship}\",\n            )\n\n        # NOTE: Turn off to not store the orders in the database\n        if shipable_orders_objs:\n            if d_db.store_purchase_orders(shipable_orders_objs):\n                # Moving the valid files to the order_logs folder\n                ftp.moving_files(all_valid_files, \"order_logs\")\n\n            else:\n                send_email(\n                    \"Error Storing Orders\",\n                    \"There was an error storing the orders in the database. Valid files were never moved from their FTP folders. Re-run the  dropship_order_import script to try again.\",\n                )\n        # Moving the invalid files to the error_logs folder\n        ftp.moving_files(all_invalid_files, \"error_logs\", remove_from_tmp=True)\n\n        d_db.close()\n\n    except Exception as e:\n        print(f\"There was an error: {e}\")\n        send_email(\"An Error Occurred\", f\"Error: {e}\\n\\n{traceback.format_exc()}\")\n        raise e\n\n\nif __name__ == \"__main__\":\n    main()\n"
      },
      {
        "filename": "config.py",
        "code": "db_config = {\n    \"ExampleDb\": {\n        \"server\": \"example.database.windows.net\",\n        \"database\": \"ExampleDb\",\n        \"username\": \"example\",\n        \"password\": \"password\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n        \"port\": 1433,  # Default port\n    },\n}\n\n\ndef create_connection_string(server_config):\n    return (\n        f\"DRIVER={server_config['driver']};\"\n        f\"SERVER={server_config['server']};\"\n        f\"PORT={server_config['port']};DATABASE={server_config['database']};\"\n        f\"UID={server_config['username']};\"\n        f\"PWD={server_config['password']}\"\n    )\n\n\nftp_server = {\n    \"server\": \"ftp.example.com\",\n    \"username\": \"example\",\n    \"password\": \"password\",\n}\n\nSENDER_EMAIL = \"sender_email@domain.com\"\nSENDER_PASSWORD = \"sender_password\"\nRECIPIENT_EMAILS = [\n    \"recipient_email_1@domail.com\",\n    \"recipient_email_2@domain.com\",\n]  # List of recipient emails\n"
      },
      {
        "filename": "email_helper.py",
        "code": "import smtplib\nfrom email.message import EmailMessage\nfrom config import SENDER_EMAIL, SENDER_PASSWORD, RECIPIENT_EMAILS\nimport os\nimport getpass\nimport socket\n\n\ndef send_email(subject, body):\n    current_dir = os.getcwd()\n    folder_name = os.path.basename(current_dir)\n    computer_name = socket.gethostname()\n    user_name = getpass.getuser()\n    new_line = \"\\n\"\n    body_with_new_line = (\n        f\"{body}{new_line}{folder_name} on {computer_name} ({user_name})\"\n    )\n    msg = EmailMessage()\n    msg.set_content(body_with_new_line)\n    msg[\"Subject\"] = f\"{subject} : {folder_name}\"\n    msg[\"From\"] = SENDER_EMAIL\n    msg[\"To\"] = \", \".join(RECIPIENT_EMAILS)\n\n    try:\n        with smtplib.SMTP_SSL(\"smtp.gmail.com\", 465) as server:\n            server.login(SENDER_EMAIL, SENDER_PASSWORD)\n            server.send_message(msg)\n        print(\"Email sent successfully.\")\n    except Exception as e:\n        print(f\"Error sending email: {e}\")\n"
      },
      {
        "filename": "example_db.py",
        "code": "import pyodbc\nfrom config import create_connection_string, db_config\nfrom email_helper import send_email\nfrom datetime import datetime\nfrom tqdm import tqdm\n\n\nclass ExampleDb:\n    def __init__(self):\n        try:\n            # DropshippSellerCloud database connection\n            self.conn_sc = pyodbc.connect(\n                create_connection_string(db_config[\"ExampleDb\"])\n            )\n            self.cursor_sc = self.conn_sc.cursor()\n        except pyodbc.Error as e:\n            print(f\"Error establishing connection to the Example database: {e}\")\n            raise\n\n    def check_for_duplicate_files(self, file_path):\n        \"\"\"Check if the file has already been uploaded to the database\"\"\"\n        try:\n            file_name = file_path.split(\"\\\\\")[-1]\n\n            self.cursor_sc.execute(\n                \"\"\"\n                SELECT * FROM PurchaseOrderFiles \n                WHERE file_name = ?\n                \"\"\",\n                file_name,\n            )\n\n            if self.cursor_sc.fetchone():\n                return False\n            else:\n                return True\n\n        except Exception as e:\n            print(f\"Error while checking for duplicate files: {e}\")\n            raise\n\n    def check_for_duplicate_orders(self, purchase_order_number):\n        \"\"\"Check if the order has already been uploaded to the database\"\"\"\n        try:\n            self.cursor_sc.execute(\n                \"\"\"\n                SELECT * FROM PurchaseOrders\n                WHERE purchase_order_number = ?\n                \"\"\",\n                purchase_order_number,\n            )\n\n            if self.cursor_sc.fetchone():\n                return True\n            else:\n                return False\n\n        except Exception as e:\n            print(f\"Error while checking for duplicate orders: {e}\")\n            raise\n\n    def store_file_names(self, file_name, pos, dropshipper_id, path):\n        \"\"\"Store the file name and purchase order numbers in the database\"\"\"\n\n        files_not_uploaded = []\n\n        try:\n            self.cursor_sc.execute(\n                \"\"\"\n                INSERT INTO PurchaseOrderFiles (dropshipper_id, file_name, date)\n                VALUES (?, ?, ?)\n                \"\"\",\n                dropshipper_id,\n                file_name,\n                datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            )\n\n            file_id = self.cursor_sc.execute(\"SELECT @@IDENTITY AS id\").fetchone().id\n\n            self.cursor_sc.executemany(\n                \"\"\"\n                INSERT INTO PurchaseOrderFileItems (purchase_order_file_id, purchase_order_number)\n                VALUES (?, ?)\n                \"\"\",\n                [(file_id, po) for po in pos],\n            )\n\n        except Exception as e:\n            print(f\"Error while storing the file path: {e}\")\n            files_not_uploaded.append(path)\n\n        self.conn_sc.commit()\n\n        if files_not_uploaded:\n            send_email(\n                \"Error Uploading Files to Database\",\n                f\"Error uploading the following files to the database: {files_not_uploaded}\",\n            )\n\n    def store_purchase_orders(self, po_objs):\n        \"\"\"Store the purchase orders in the database\"\"\"\n\n        for po_obj in tqdm(po_objs.values(), desc=\"Storing purchase orders\"):\n            try:\n                # Inserting into PurchaseOrders\n                self.cursor_sc.execute(\n                    \"\"\"\n                            INSERT INTO PurchaseOrders (\n                                purchase_order_number,\n                                purchase_order_date,\n                                date_added,\n                                customer_first_name,\n                                customer_last_name,\n                                address,\n                                city,\n                                state,\n                                zip,\n                                country,\n                                phone,\n                                dropshipper_id)\n                                VALUES (?, ?, ?, ?, ?, ?, ?, \n                                (SELECT id FROM States WHERE code = ?), ?, \n                                (SELECT id FROM Countries WHERE two_letter_code = ?), ?, ?)\n                                \"\"\",\n                    po_obj[\"purchase_order_number\"],\n                    po_obj[\"purchase_order_date\"],\n                    datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                    po_obj[\"customer_first_name\"],\n                    po_obj[\"customer_last_name\"],\n                    po_obj[\"address\"],\n                    po_obj[\"city\"],\n                    po_obj[\"state\"],\n                    po_obj[\"zip\"],\n                    po_obj[\"country\"],\n                    po_obj[\"phone\"],\n                    po_obj[\"dropshipper_id\"],\n                )\n\n                purchase_order_id = (\n                    self.cursor_sc.execute(\"SELECT @@IDENTITY AS id\").fetchone().id\n                )\n\n                for sku, quantity in po_obj[\"items\"].items():\n                    self.cursor_sc.execute(\n                        \"\"\"\n                                INSERT INTO PurchaseOrderItems (\n                                    purchase_order_id,\n                                    sku,\n                                    quantity)\n                                    VALUES (?, ?, ?)\n                                    \"\"\",\n                        purchase_order_id,\n                        sku,\n                        quantity,\n                    )\n\n            except Exception as e:\n                print(f\"Error while storing new purchase orders: {e}\")\n                self.conn_sc.rollback()\n                send_email(\n                    \"Error Storing Orders\",\n                    f\"The following error occurred while storing new purchase orders: {e}\\norder: {po_obj} was unable to be stored in the ExampleDb.\",\n                )\n                continue\n\n        self.conn_sc.commit()\n\n        return True\n\n    def load_dropship_data(self):\n        \"\"\"Load dropshipper data from the database\"\"\"\n\n        try:\n            self.cursor_sc.execute(\n                \"\"\"\n                SELECT \n                    d.id,\n                    d.name,\n                    d.code,\n                    d.use_our_shipping_account,\n                    d.ftp_folder_name,\n                    ff.name AS format_name,\n                    po_ffd.header_name AS po_header_name, -- Specific PO header name\n                    STRING_AGG(ffd.header_name, ', ') WITHIN GROUP (ORDER BY ffd.header_order) AS all_header_names -- Aggregate all header names\n                FROM \n                    dropshippers d \n                JOIN \n                    DropshipperFileFormats dff ON dff.dropshipper_id = d.id\n                JOIN \n                    FileFormats ff ON ff.id = dff.format_id\n                LEFT JOIN \n                    FileFormatDetails po_ffd ON po_ffd.id = d.po_header_format_detail_id\n                JOIN \n                    FileFormatDetails ffd ON ffd.format_id = ff.id\n                WHERE \n                    ff.type = 'order' \n                    AND d.po_header_format_detail_id IS NOT NULL\n                GROUP BY \n                    d.id, d.name, d.code, d.use_our_shipping_account, d.ftp_folder_name, ff.name, po_ffd.header_name\n                ORDER BY \n                    d.name;\n                \"\"\"\n            )\n            dropshipper_data = {}\n\n            for row in self.cursor_sc.fetchall():\n                dropshipper_data[row.ftp_folder_name] = {\n                    \"id\": row.id,\n                    \"name\": row.name,\n                    \"code\": row.code,\n                    \"use_our_shipping_account\": row.use_our_shipping_account,\n                    \"ftp_folder_name\": row.ftp_folder_name,\n                    \"format\": row.format_name,\n                    \"po_header_name\": row.po_header_name,\n                    \"headers\": row.all_header_names.split(\", \"),\n                }\n\n            return dropshipper_data\n\n        except Exception as e:\n            print(f\"Error while getting data from the Dropship database: {e}\")\n            raise\n\n    def get_country_and_states(self):\n        \"\"\"Get country and states from the database\"\"\"\n\n        try:\n            self.cursor_sc.execute(\n                \"\"\"\n                SELECT\n                    c.name as country_name,\n                    c.two_letter_code,\n                    c.three_letter_code, \n                    s.code, \n                    s.name as state_name\n                FROM Countries c\n                JOIN States s ON s.country_id = c.id\n                \"\"\"\n            )\n\n            rows = self.cursor_sc.fetchall()\n            if rows:\n                result = {}\n                for row in rows:\n                    country_key = (\n                        row.country_name,\n                        row.two_letter_code,\n                        row.three_letter_code,\n                    )\n                    if country_key not in result:\n                        result[country_key] = {}\n                    result[country_key][row.state_name] = row.code\n\n            return result\n\n        except Exception as e:\n            print(f\"Error while getting country and states: {e}\")\n            raise\n\n    def get_header_maps(self):\n        \"\"\"Get header mappings from the database. The header mapping are necessary because not al dropshippers use the same headers\"\"\"\n\n        try:\n            query = \"\"\"\n                    SELECT  hm.normalized_name, ffd.header_name\n                    FROM FileFormatDetails ffd\n                    INNER JOIN HeaderMappings hm ON ffd.header_mapping_id = hm.id\n                    \"\"\"\n            self.cursor_sc.execute(query)\n\n            rows = self.cursor_sc.fetchall()\n\n            header_variants = {}\n            for normalized_name, variant in rows:\n                if normalized_name in header_variants:\n                    header_variants[normalized_name].append(variant)\n                else:\n                    header_variants[normalized_name] = [variant]\n\n            return header_variants\n\n        except Exception as e:\n            print(f\"Error while getting header maps: {e}\")\n            raise\n\n    def load_excluded_shipping_states(self):\n        \"\"\"Returns a list of state codes where our shipping account does not ship to\"\"\"\n        try:\n            self.cursor_sc.execute(\n                \"\"\"\n                SELECT DISTINCT s.code FROM States s\n                JOIN ExcludedShippingStates ess ON ess.state_id = s.id\n                \"\"\"\n            )\n            return [row.code for row in self.cursor_sc.fetchall()]\n\n        except Exception as e:\n            print(f\"Error while getting excluded shipping states: {e}\")\n            raise\n\n    def get_international_accounts(self):\n        \"\"\"Get the international dropshipper shipping accounts\"\"\"\n\n        try:\n            self.cursor_sc.execute(\n                \"\"\"\n                SELECT id, code FROM Dropshippers\n                WHERE name LIKE '%international%'\n                \"\"\"\n            )\n\n            return {\n                self._get_dropshipper_id(row.code): row.id\n                for row in self.cursor_sc.fetchall()\n            }\n\n        except Exception as e:\n            print(f\"Error while getting international accounts: {e}\")\n            raise\n\n    def _get_dropshipper_id(self, dropshipper_code):\n        \"\"\"Get the dropshipper id from the database\"\"\"\n\n        try:\n            self.cursor_sc.execute(\n                \"\"\"\n                SELECT id FROM Dropshippers\n                WHERE code = ?\n                \"\"\",\n                dropshipper_code,\n            )\n            return self.cursor_sc.fetchone().id\n        except Exception as e:\n            print(f\"Error while getting dropshipper id: {e}\")\n            raise\n\n    def close(self):\n        self.cursor_sc.close()\n        self.conn_sc.close()\n"
      },
      {
        "filename": "ftp.py",
        "code": "import os\nimport ftplib\nimport pathlib\nfrom datetime import datetime\nfrom config import ftp_server\nfrom tqdm import tqdm\n\n\nclass FTPManager:\n    def __init__(self):\n        self.host = ftp_server[\"server\"]\n        self.username = ftp_server[\"username\"]\n        self.password = ftp_server[\"password\"]\n\n    def _create_local_dir(self, customer_name):\n        \"\"\"Create a local directory to store the downloaded files\"\"\"\n\n        datetime_now = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        local_dir = pathlib.Path(f\"tmp/{customer_name}/{datetime_now}/\")\n        local_dir.mkdir(parents=True, exist_ok=True)\n        return local_dir\n\n    def download_files(self, ftp_folder_name):\n        \"\"\"Download order files from the FTP server\"\"\"\n\n        try:\n            # Starting connection to FTP\n            self.ftp = ftplib.FTP(self.host)\n            self.ftp.login(self.username, self.password)\n\n            # remote_folder = f\"test_dropshipper/{ftp_folder_name}/orders\"\n            remote_folder = f\"dropshipper/{ftp_folder_name}/orders\"\n\n            files = self.ftp.nlst(remote_folder)\n\n            # Create the local directory for downloads\n            local_dir = self._create_local_dir(ftp_folder_name)\n\n            for file in tqdm(files, desc=f\"Downloading {ftp_folder_name} files\"):\n                # Skip directories\n                if file.endswith(\"/\"):\n                    continue\n\n                # Construct the local file path\n                local_file_path = local_dir / pathlib.Path(file).name\n\n                # Download the file\n                with open(local_file_path, \"wb\") as local_file:\n                    self.ftp.retrbinary(\n                        f\"RETR {remote_folder}/{pathlib.Path(file).name}\",\n                        local_file.write,\n                    )\n\n            self.ftp.quit()\n\n            return str(local_dir)\n\n        except ftplib.all_errors as e:\n            # Closing\n            self.ftp.quit()\n\n            print(f\"There was an error downloading order files from FTP server: {e}\")\n\n    def moving_files(self, all_files, destination, remove_from_tmp=False):\n        \"\"\"Move files to the logs folder in the FTP server\"\"\"\n\n        try:\n            # Starting connection to FTP\n            self.ftp = ftplib.FTP(self.host)\n            self.ftp.login(self.username, self.password)\n\n            for dropshiper_file_path in tqdm(\n                all_files.values(), desc=f\"Moving valid files to {destination}\"\n            ):\n                for tupple in dropshiper_file_path:\n                    # The tupple can be a file path or a tupple with the file path and the reason\n                    if remove_from_tmp:\n                        file_path = tupple[0]\n                    else:\n                        file_path = tupple\n\n                    if remove_from_tmp:\n                        # Removing file from tmp folder\n                        os.remove(file_path)\n\n                    ftp_folder_name = file_path.split(\"\\\\\")[1]\n                    file_name = file_path.split(\"\\\\\")[-1]\n\n                    origin_folder = (\n                        f\"dropshipper/{ftp_folder_name}/orders/{file_name}\"\n                        # f\"test_dropshipper/{ftp_folder_name}/orders/{file_name}\"\n                    )\n                    log_folder = (\n                        f\"dropshipper_logs/{destination}/{ftp_folder_name}/{file_name}\"\n                    )\n\n                    try:\n                        self.ftp.rename(origin_folder, log_folder)\n                        print(\n                            f\"File moved successfully from {origin_folder} to {log_folder}\"\n                        )\n\n                    except ftplib.all_errors as e:\n                        print(\n                            f\"There was an error moving invalid folders in the FTP server: {e}\"\n                        )\n\n            # Closing\n            self.ftp.quit()\n\n        except ftplib.all_errors as e:\n            print(f\"There was an error removing files from FTP server: {e}\")\n"
      },
      {
        "filename": "invalid_file_checker.py",
        "code": "from typing import Callable\nimport pandas as pd\nfrom example_db import ExampleDb\nfrom xlsx_parser import XlsxParser\nfrom tqdm import tqdm\nimport os\n\n\nclass InvalidFileChecker:\n    def __init__(self, d_db: ExampleDb, parser: XlsxParser):\n        self.d_db = d_db\n        self.parser = parser\n\n    def _check(self, file_path: str, rule: Callable[[str], bool]) -> bool:\n        \"\"\"Check if a file passes a rule\"\"\"\n\n        return rule(file_path)\n\n    def validate_files(self, file_path, header_template):\n        \"\"\"Validate files in a folder\"\"\"\n\n        invalid_files = []\n        valid_files = []\n\n        # Checking if file is invalid\n        for root, dirs, files in os.walk(file_path):\n            for file in tqdm(files, desc=f\"Checking for valid files in folder{root}\"):\n                # Getting the header template for the specific customer\n                full_path = os.path.join(root, file)\n                # Validity flag\n                is_valid = True\n\n                # List of rules NOTE: add more if needed\n                rules = [\n                    is_not_empty,\n                    is_csv,\n                    follows_template(header_template, self.parser),\n                    is_not_duplicate(self.d_db),\n                    it_has_required_content(self.parser),\n                ]\n\n                # Checking if file is invalid\n                for rule in rules:\n                    valid, reason = self._check(full_path, rule)\n                    if not valid:\n                        invalid_files.append((full_path, reason))\n\n                        is_valid = False\n\n                        print(f\"File {full_path} is invalid\")\n                        break\n\n                if is_valid:\n                    valid_files.append(full_path)\n\n        return valid_files, invalid_files\n\n\ndef clean_and_save_csv(csv_file_path):\n    # Read the CSV into a DataFrame\n    df = pd.read_csv(csv_file_path)\n\n    # Remove spaces from column headers\n    df.columns = df.columns.str.replace(\" \", \"\", regex=True)\n\n    # Save the DataFrame back to the same CSV file\n    df.to_csv(csv_file_path, index=False)\n\n\n# Rules for checking files ========================================\ndef is_not_empty(file_path: str) -> bool:\n    \"\"\"Check if a file is empty\"\"\"\n\n    result = os.path.getsize(file_path) > 0\n    if result:\n        return True, None\n    else:\n        return False, \"File is empty\"\n\n\ndef is_csv(file_path: str) -> bool:\n    \"\"\"Check if a file is a csv\"\"\"\n\n    result = file_path.endswith(\".csv\")\n    if result:\n        return True, None\n    else:\n        return False, \"File is not a csv\"\n\n\ndef follows_template(\n    header_template: list, parser: XlsxParser\n) -> Callable[[str], bool]:\n    \"\"\"Check if a file follows a template\"\"\"\n\n    def check_template(file_path: str) -> bool:\n        try:\n            clean_and_save_csv(file_path)\n\n            df = parser._df_reader(file_path)\n            columns = df.columns.tolist()\n\n            result = columns == header_template\n            if result:\n                return True, None\n            else:\n                return False, \"File does not follow template\"\n\n        except Exception as e:\n            return False, \"There was an error checking the template\"\n\n    return check_template\n\n\ndef is_not_duplicate(d_db: ExampleDb) -> Callable[[str], bool]:\n    \"\"\"Check if a file is a duplicate\"\"\"\n\n    def check_for_duplicate(file_path: str) -> bool:\n        result = d_db.check_for_duplicate(file_path)\n        if result:\n            return True, None\n        else:\n            return False, \"File is a duplicate\"\n\n    return check_for_duplicate\n\n\ndef it_has_required_content(parser: XlsxParser) -> Callable[[str], bool]:\n    \"\"\"Check if a file has required content\"\"\"\n\n    def check_column_values(file_path: str) -> bool:\n        try:\n            df = parser._df_reader(file_path)\n            df.dropna(how=\"all\", inplace=True)\n\n            required_columns = [\n                \"purchase_order_number\",\n                \"customer_first_name\",\n                \"address_1\",\n                \"city\",\n                \"country\",\n                \"state\",\n                \"zip\",\n                \"sku\",\n                \"quantity\",\n            ]\n\n            df = parser.standardize_columns(df)\n\n            for column in required_columns:\n                values = df[column].tolist()\n                values = [value for value in values if pd.notna(value)]\n\n                result = len(values) > 0\n\n                if not result:\n                    return False, f\"Column {column} is empty\"\n                else:\n                    continue\n\n            return True, None\n\n        except Exception as e:\n            return False\n\n    return check_column_values\n"
      },
      
      {
        "filename": "xlsx_parser.py",
        "code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime\nfrom example_db import ExampleDb\nfrom tqdm import tqdm\nimport re\n\n\nclass XlsxParser:\n    def __init__(self, dropshipper_data, d_db: ExampleDb):\n        self.dropshipper_data = dropshipper_data\n        self.d_db = d_db\n        self.headder_maps = self.d_db.get_header_maps()\n        self.country_and_states = self.d_db.get_country_and_states()\n\n    def check_shipping_states(\n        self, all_po_objs, excluded_shipping_states, international_accounts\n    ):\n        \"\"\"This function removes orders with excluded shipping states\"\"\"\n        try:\n            shipable_orders_objs = {}\n            unable_to_ship = {}\n            for po_number, po_obj in tqdm(\n                all_po_objs.items(), desc=\"Checking shipping states\"\n            ):\n                if po_obj[\"state\"] not in excluded_shipping_states:\n                    shipable_orders_objs[po_number] = po_obj\n                elif po_obj[\"dropshipper_id\"] in international_accounts:\n                    po_obj[\"dropshipper_id\"] = international_accounts[\n                        po_obj[\"dropshipper_id\"]\n                    ]\n                    shipable_orders_objs[po_number] = po_obj\n                else:\n                    unable_to_ship[po_number] = po_obj\n\n            return unable_to_ship, shipable_orders_objs\n        except Exception as e:\n            print(f\"Error checking shipping states: {e}\")\n            raise\n\n    def file_parser(self, valid_files):\n        \"\"\"This function parses the files and returns a list of purchase order objects\"\"\"\n        dfs = []\n        for dropshipper_id, file_paths in valid_files.items():\n            for file_path in file_paths:\n                df = self._df_reader(file_path)\n                # Removing whitespaces from the column names\n                df.columns = [col.replace(\" \", \"\") for col in df.columns]\n                df = df.dropna(how=\"all\").fillna(\"\")\n                # Adding the dropshipper_id column to the dataframe\n                df.loc[:, \"dropshipper_id\"] = np.nan\n                # Updating the dropshipper_id column to the value for rows where the column is not empty\n                df.loc[df.notna().any(axis=1), \"dropshipper_id\"] = dropshipper_id\n                dfs.append(self.standardize_columns(df))\n\n        # Concatenating all the dataframes into one\n        df = pd.concat(dfs, ignore_index=True)\n\n        return self._parse(df)\n\n    def standardize_columns(self, df):\n        \"\"\"This function standardizes the columns of the dataframe by renaming them to the standard names\"\"\"\n\n        for standard_name, variant_names in self.headder_maps.items():\n            for variant_name in variant_names:\n                if variant_name in df.columns:\n                    df.rename(columns={variant_name: standard_name}, inplace=True)\n                    break\n        return df\n\n    def _transform_data(self, df):\n        \"\"\"This function transforms the data in the dataframe\"\"\"\n\n        # Transform city\n        df[\"city\"] = df[\"city\"].apply(self._text_formater)\n\n        # Zip code formatting\n        df[\"zip\"] = df[\"zip\"].apply(self._zip_formater)\n\n        # Name formatting\n        df[\"customer_first_name\"] = df[\"customer_first_name\"].apply(lambda x: x.title())\n        df[\"customer_last_name\"] = df[\"customer_last_name\"].apply(lambda x: x.title())\n\n        # Address concatenation\n        df[\"address\"] = df.apply(\n            lambda row: (\n                row[\"address_1\"] + \" \" + row[\"address_2\"]\n                if \"address_2\" in row\n                else row[\"address_1\"]\n            ),\n            axis=1,\n        )\n\n        # Country and State formatting\n        df[[\"country\", \"state\"]] = df.apply(\n            lambda row: pd.Series(\n                self._country_and_state_formater(row[\"country\"], row[\"state\"])\n            ),\n            axis=1,\n        )\n\n        # Phone number formatting\n        df[\"phone\"] = df[\"phone\"].apply(self._phone_formater)\n\n        # Handling missing purchase order dates\n        if \"purchase_order_date\" not in df.columns:\n            df[\"purchase_order_date\"] = \"\"\n\n        df[\"purchase_order_date\"] = df[\"purchase_order_date\"].apply(\n            lambda x: datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") if x == \"\" else x\n        )\n\n        # Convert quantity to integer\n        df[\"quantity\"] = df[\"quantity\"].astype(int)\n\n        # Convert dropshipper ID to integer\n        df[\"dropshipper_id\"] = df[\"dropshipper_id\"].astype(int)\n\n        return df\n\n    def _has_all_required_columns(self, row: pd.Series):\n        \"\"\"This function checks if the row has all the required columns\"\"\"\n\n        required_columns = [\n            \"purchase_order_number\",\n            \"customer_first_name\",\n            \"address_1\",\n            \"city\",\n            \"country\",\n            \"state\",\n            \"zip\",\n            \"sku\",\n            \"quantity\",\n        ]\n\n        # Identify missing columns\n        missing_columns = [col for col in required_columns if getattr(row, col) == \"\"]\n\n        if missing_columns:\n            return False, missing_columns\n        else:\n            return True, missing_columns\n\n    def _has_valid_sku(self, sku):\n        \"\"\"This function checks if the sku has valid characters\"\"\"\n\n        pattern = r\"^[a-zA-Z0-9/-]*$\"\n        return bool(re.match(pattern, sku))\n\n    def _parse(self, df):\n        \"\"\"This function parses the dataframe and returns a list of purchase order objects\"\"\"\n        unparsed_skus = {}\n        po_objs = {}\n\n        df = df.dropna(how=\"all\").fillna(\"\")\n\n        df = self._transform_data(df)\n\n        for row in tqdm(df.itertuples(), desc=\"Parsing files\"):\n            try:\n                sku = row.sku.replace(\" \", \"\")\n                able_to_parse, missing_columns = self._has_all_required_columns(row)\n                correct_sku_format = self._has_valid_sku(sku)\n\n                if row.city == \"\" or row.country == \"\" or row.state == \"\":\n                    pass\n\n                if not able_to_parse:\n                    raise Exception(\"Missing required columns\")\n\n                if not correct_sku_format:\n                    raise Exception(\"Sku has invalid characters\")\n\n                purchase_order_number = row.purchase_order_number\n\n                # This checks if the purchase order number is already in the dictionary if it is it adds the item to the items list\n                if purchase_order_number in po_objs:\n                    po_objs[purchase_order_number][\"items\"][sku] = row.quantity\n                    continue\n\n                # If the purchase order number is not in the dictionary it creates a new purchase order object\n                else:\n                    # The key in the purchase order object is the purchase order number\n                    po_objs[purchase_order_number] = {}\n                    po_obj = po_objs[purchase_order_number]\n                    po_obj[\"purchase_order_number\"] = purchase_order_number\n                    po_obj[\"purchase_order_date\"] = row.purchase_order_date\n                    po_obj[\"customer_first_name\"] = row.customer_first_name\n                    po_obj[\"customer_last_name\"] = row.customer_last_name\n                    po_obj[\"address\"] = row.address\n                    po_obj[\"city\"] = row.city\n                    po_obj[\"country\"] = row.country\n                    po_obj[\"state\"] = row.state\n                    po_obj[\"zip\"] = row.zip\n                    po_obj[\"phone\"] = row.phone\n                    po_obj[\"dropshipper_id\"] = row.dropshipper_id\n                    po_obj[\"items\"] = {sku: row.quantity}\n\n            except Exception as e:\n                # Finding the dropshipper name\n                for data in self.dropshipper_data.values():\n                    if data[\"id\"] == row.dropshipper_id:\n                        dropshipper_name = data[\"name\"]\n                        break\n\n                if dropshipper_name in unparsed_skus:\n                    unparsed_skus[dropshipper_name].append((row, missing_columns))\n                else:\n                    unparsed_skus[dropshipper_name] = [(row, missing_columns)]\n\n                continue\n\n        return po_objs, unparsed_skus\n\n    def _country_and_state_formater(self, country, state):\n        \"\"\"This function formats the country and state to the two letter codes\"\"\"\n        try:\n            # Removing anythis that is not a letter\n            country = re.sub(\"[^a-zA-Z]+\", \"\", country)\n            state = re.sub(\"[^a-zA-Z]+\", \"\", state)\n            country_not_found = False\n\n            for country_key, states in self.country_and_states.items():\n                # It checks if the country in the dataframe is in the country and states dictionary\n                if country.upper() in country_key or country.title() in country_key:\n                    country_two_letter_code = country_key[1]\n                    country = country_two_letter_code\n\n                    # If the state string is longer than 2 characters it checks if the full state name is in the states dictionary\n                    if len(state) > 2:\n                        state = states[state.title()]\n                    # Else it returns the state as is but capitalized\n                    else:\n                        state = state.upper()\n\n                    country_not_found = False\n                    break\n\n                else:\n                    country_not_found = True\n\n            if country_not_found:\n                country = None\n                state = None\n\n            return country, state\n\n        except Exception as e:\n            print(f\"Error formating country and state: {e}\")\n            return country, state\n\n    def _text_formater(self, text, remove_empty_spaces=False):\n        \"\"\"This function formats the test to title case and removes all non letter characters\"\"\"\n        try:\n            if remove_empty_spaces:\n                # Removing anything that is not a letter or an empty space\n                text = re.sub(\"[^a-zA-Z]+\", \"\", text)\n            else:\n                # Removing anything that is not a letter\n                text = re.sub(\"[^a-zA-Z ]+\", \"\", text)\n\n            # Correcting the capitalization\n            if text.isupper():\n                return text.title()\n            return text\n        except Exception as e:\n            print(f\"Error formating text: {e}\")\n            return text\n\n    def _phone_formater(self, phone, shipstation=False):\n        \"\"\"This function formats the phone number to an int and removes all non numeric characters\"\"\"\n        remove = \"[^0-9]\"\n        try:\n            if shipstation:\n                # Extracting just the phone number digits, excluding the extension\n                phone_number_match = re.search(\n                    r\"\\+?\\d+[\\s-]?(\\d+)[\\s-]?(\\d+)[\\s-]?(\\d+)\", phone\n                )\n\n                if phone_number_match:\n                    phone = int(\"\".join(phone_number_match.groups()))\n                else:\n                    phone = 0\n            else:\n                phone = int(re.sub(remove, \"\", phone))\n\n            # if phone == 0 or None:\n            #     phone = None\n\n            return phone\n        except Exception as e:\n            print(f\"Error formating phone number: {e}\")\n            return phone\n\n    def _zip_formater(self, zip_code):\n        if len(zip_code) < 5:\n            return str(zip_code).zfill(5)\n        if len(zip_code) > 5:\n            return zip_code[:5]\n        else:\n            return zip_code\n\n    def _df_reader(self, file_path):\n        \"\"\"This function reads the file and returns a dataframe\"\"\"\n        try:\n            df = pd.read_csv(file_path, dtype=str, encoding=\"utf-8\")\n\n        except UnicodeDecodeError:\n            try:\n                df = pd.read_csv(\n                    file_path, dtype=str, encoding=\"ISO-8859-1\"\n                )  # Trying with latin1 encoding\n            except UnicodeDecodeError:\n                try:\n                    df = pd.read_csv(\n                        file_path, dtype=str, encoding=\"cp1252\"\n                    )  # Trying with Windows encoding\n                except UnicodeDecodeError as e:\n                    print(f\"Error reading the file: {e}\")\n                    return None\n\n        return df\n\n    def data_extractor(self, path, po_header_name):\n        try:\n            file_name = path.split(\"\\\\\")[-1]\n\n            pos = []\n\n            df = self._df_reader(path)\n            df = df[pd.notnull(df[po_header_name]) & (df[po_header_name] != \"\")]\n            df[po_header_name] = df[po_header_name].astype(str)\n            pos = df[po_header_name].tolist()\n\n            return file_name, pos\n\n        except Exception as e:\n            print(f\"Error while parsing the path: {e}\")\n\n    def _sku_cleaner(self, sku_number):\n        \"\"\"This function cleans the skus\"\"\"\n        starts_with_sku = sku_number.startswith(\"SKU \")\n        if starts_with_sku:\n            return None\n        # Check for 'S' at start and '-R', '-S', or '-P' anywhere in sku\n        elif sku_number.startswith(\"S\") or any(\n            marker in sku_number for marker in [\"-R\", \"-S\", \"-P\", \"-FBA\"]\n        ):\n            # Use regex to remove 'S' at start and '-R', '-S', '-P' anywhere\n            sku_number = re.sub(r\"^S|(-R)|(-S)|(-P)|(-FBA)\", \"\", sku_number)\n        elif \"-SML\" in sku_number:\n            # No action needed, alias is already None\n            pass\n\n        return sku_number\n"
      }
    ],
    "repoLink": "https://github.com/aborroto1984/dropship_order_intake",
    "technologies": [
      { name: "Python", icon: `${process.env.PUBLIC_URL}/icons/python.png` },
      { name: "API", icon: `${process.env.PUBLIC_URL}/icons/API.png` },
      { name: "Azure", icon: `${process.env.PUBLIC_URL}/icons/azure.png` },
      { name: "Pandas", icon: `${process.env.PUBLIC_URL}/icons/pandas.png` },
      { name: "SQL", icon: `${process.env.PUBLIC_URL}/icons/sql.png` },
      { name: "Git", icon: `${process.env.PUBLIC_URL}/icons/git.png` },
      { name: "Numpy", icon: `${process.env.PUBLIC_URL}/icons/numpy.png` },
      { name: "Files.com", icon: `${process.env.PUBLIC_URL}/icons/files.png` },
    ]
  },
  {
    "title": "Dropship Order Invoice Report",
    "description": "This project automates order processing, invoice generation, and data management using multiple integrations, including FTP servers, SellerCloud, and QuickBooks.",
    "files": [
      {
        "filename": "README.md",
        "code":`# Order Invoicing and Processing System

This project automates order processing, invoice generation, and data management using multiple integrations, including FTP servers, SellerCloud, and QuickBooks.

## Features
- Fetches and processes orders from SellerCloud.
- Validates order files and invoice data.
- Rounds decimal values for financial accuracy.
- Creates invoices and sends them to QuickBooks.
- Uploads processed files to an FTP server.
- Stores and retrieves order data from an SQL database.
- Sends email notifications for errors and important updates.

## Project Structure
project_root/ ├── config.py # Configuration file for database, API, and email credentials 
              ├── decimal_rounding.py # Handles rounding of decimal values 
              ├── df_creator.py # Handles invoice data structuring 
              ├── email_helper.py # Sends email notifications 
              ├── exampple_db.py # Manages database interactions for invoicing 
              ├── file_handler.py # Handles file creation and storage 
              ├── ftp.py # Manages FTP file uploads 
              ├── invoice.py # Handles invoice creation via QuickBooks API 
              ├── main.py # Main script orchestrating the invoicing process 
              ├── quick_books_db.py # Manages QuickBooks API tokens 
              ├── seller_cloud_api.py # Interfaces with SellerCloud API 
              ├── seller_cloud_data.py # Fetches and processes SellerCloud order data

## Installation & Setup

### 1. Clone the Repository

git clone https://github.com/your-repo/order-processing.git
cd order-processing

### 2. Install Dependencies
Ensure you have Python 3 installed, then install dependencies:
pip install -r requirements.txt

### 3. Configure the System
Modify config.py with your database, FTP, and API credentials.

## Example database configuration:

db_config = {
    "ExampleDb": {
        "server": "your.database.windows.net",
        "database": "YourDB",
        "username": "your_user",
        "password": "your_password",
        "driver": "{ODBC Driver 17 for SQL Server}",
    },
}

## Example email configuration:

SENDER_EMAIL = "your_email@example.com"
SENDER_PASSWORD = "your_email_password"

## Usage

Run the main script to start the process:
python main.py

## How It Works

- Fetches order data from SellerCloud.
- Validates and processes invoice data.
- Rounds decimal values for financial accuracy.
- Generates invoices and sends them to QuickBooks.
- Uploads processed invoice files to an FTP server.
- Updates the database with invoice details.
- Sends email notifications for errors or missing data.

# Tech Stack

- Python 3
- Azure SQL Database (pyodbc)
- FTP File Handling (ftplib)
- SellerCloud API Integration
- QuickBooks API Integration
- Email Notifications (smtplib)
- Pandas for data handling
- Decimal rounding for financial accuracy

# Troubleshooting

- If you encounter database connection issues, ensure ODBC Driver 17 is installed.
- If emails fail to send, ensure your SMTP settings allow external authentication.
- Verify SellerCloud and QuickBooks credentials if API requests fail.`
      },
      {
        "filename": "config.py",
        "code": "db_config = {\n    \"ExampleDb\": {\n        \"server\": \"example.database.windows.net\",\n        \"database\": \"ExampleDb\",\n        \"username\": \"example\",\n        \"password\": \"example\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n        \"port\": 1433,  # Default port for SQL Server\n    },\n    \"QuickBooks_ExampleDb\": {\n        \"server\": \"example.database.windows.net\",\n        \"database\": \"QuickBooks_ExampleDb\",\n        \"username\": \"example\",\n        \"password\": \"example\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n        \"port\": 1433,  # Default port for SQL Server\n    },\n}\n\n\ndef create_connection_string(server_config):\n    return (\n        f\"DRIVER={server_config['driver']};\"\n        f\"SERVER={server_config['server']};\"\n        f\"PORT={server_config[\"port\"]};DATABASE={server_config['database']};\"\n        f\"UID={server_config['username']};\"\n        f\"PWD={server_config['password']}\"\n    )\n\n\nftp_server = {\n    \"server\": \"ftp.example.com\",\n    \"username\": \"example\",\n    \"password\": \"password\",\n}\n\n\nclient_data = {\n    \"client_id\": \"example_client_id\",\n    \"client_secret\": \"example_client_secret\",\n    \"redirect_uri\": \"example_redirect_uri\",\n    \"environment\": \"sandbox\",\n    \"realm_id\": \"example_realm_id\",\n    \"access_token\": \"example_access_token\",\n}\n\n\nsellercloud_credentials = {\n    \"Username\": \"username\",\n    \"Password\": \"password\",\n}\n\nsellercloud_base_url = \"https://example_company.api.sellercloud.us/rest/api/\"\nsellercloud_endpoints = {\n    \"GET_TOKEN\": {\n        \"type\": \"post\",\n        \"url\": sellercloud_base_url + \"token\",\n        \"endpoint_error_message\": \"while getting SellerCoud API access token: \",\n        \"success_message\": \"Got SellerCloud API access token successfully!\",\n    },\n    \"GET_ORDERS\": {\n        \"type\": \"get\",\n        \"url\": sellercloud_base_url + \"Orders/{order_id}\",\n        \"endpoint_error_message\": \"while getting order from SellerCloud: \",\n        \"success_message\": \"Got an order successfully!\",\n    },\n}\n\n\nSENDER_EMAIL = \"sender_email@domain.com\"\nSENDER_PASSWORD = \"sender_password\"\nRECIPIENT_EMAILS = [\n    \"recipient_email_1@domain.com\",\n    \"recipient_email_2@domain.com\",\n]  # List of emails to send the report\n"
      },
      {
        "filename": "decimal_rounding.py",
        "code": "from decimal import Decimal, ROUND_HALF_UP\n\n\ndef round_to_decimal(number):\n    \"\"\"Round a number to a given precision.\"\"\"\n    decimal_number = Decimal(str(number))\n    rounded_number = decimal_number.quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)\n\n    return float(rounded_number)\n"
      },
      {
        "filename": "df_creator.py",
        "code": "import pandas as pd\nfrom decimal_rounding import round_to_decimal\n\n\nclass DfCreator:\n    def __init__(self, invoice_csv_headers, dropshipper_data):\n        self.file_format_name = dropshipper_data[\"file_format_name\"]\n\n        # Creating a dataframe to store the invoice data\n        self.invoice_file_df = pd.DataFrame(\n            columns=invoice_csv_headers[self.file_format_name]\n        )\n\n    def populate_df(self, order):\n        \"\"\"Populates the dataframe with the order data.\"\"\"\n        try:\n\n            if self.file_format_name == \"default\":\n                row = {\n                    \"po_number\": order[\"purchase_order_number\"],\n                    \"invoice_number\": order[\"order_id\"],\n                    \"invoice_date\": order[\"ship_date\"],\n                    \"invoice_total_amount\": order[\"subtotal\"],\n                    \"invoice_subtotal_amount\": round_to_decimal(\n                        order[\"subtotal\"] - order[\"tax\"]\n                    ),\n                    \"invoice_tax_amount\": order[\"tax\"],\n                }\n                for item in order[\"items\"]:\n                    sku, quantity, unit_cost = item\n                    row[\"line_item_sku\"] = sku\n                    row[\"line_item_quantity\"] = quantity\n                    row[\"line_item_unit_cost\"] = unit_cost\n\n                    self.invoice_file_df = self.invoice_file_df._append(\n                        row, ignore_index=True\n                    )\n\n            # If the file format is aag, the invoice data is stored in a different way\n            elif self.file_format_name == \"aag\":\n                row = {}\n                for item in order[\"items\"]:\n                    sku, quantity, unit_cost = item\n                    row = {\n                        \"Invoice Number\": order[\"order_id\"],\n                        \"SONumber\": order[\"purchase_order_number\"],\n                        \"Date\": order[\"ship_date\"],\n                        \"Customer\": \"auto_accessories_garage\",\n                        \"CarrierName\": \"FEDEX_GROUND\",\n                        \"TrackingNumber\": order[\"tracking_number\"],\n                        \"item\": sku,\n                        \"qty\": quantity,\n                        \"price\": unit_cost * quantity,\n                    }\n                    self.invoice_file_df = self.invoice_file_df._append(\n                        row, ignore_index=True\n                    )\n                tax_row = {\n                    \"Invoice Number\": order[\"order_id\"],\n                    \"SONumber\": order[\"purchase_order_number\"],\n                    \"Date\": order[\"ship_date\"],\n                    \"Customer\": \"auto_accessories_garage\",\n                    \"CarrierName\": \"FEDEX_GROUND\",\n                    \"TrackingNumber\": order[\"tracking_number\"],\n                    \"item\": \"Taxes\",\n                    \"qty\": 1,\n                    \"price\": order[\"tax\"],\n                }\n                self.invoice_file_df = self.invoice_file_df._append(\n                    tax_row, ignore_index=True\n                )\n                shipping_row = {\n                    \"Invoice Number\": order[\"order_id\"],\n                    \"SONumber\": order[\"purchase_order_number\"],\n                    \"Date\": order[\"ship_date\"],\n                    \"Customer\": \"auto_accessories_garage\",\n                    \"CarrierName\": \"FEDEX_GROUND\",\n                    \"TrackingNumber\": order[\"tracking_number\"],\n                    \"item\": \"SHIPPING\",\n                    \"qty\": 1,\n                    \"price\": order[\"shipping\"],\n                }\n                self.invoice_file_df = self.invoice_file_df._append(\n                    shipping_row, ignore_index=True\n                )\n\n            return True\n\n        except Exception as e:\n            print(f\"Error while populating dataframe: {e}\")\n\n            return False\n\n    def _order_invoice_matcher(self, order, invoice):\n        order_items = {}\n        order[\"subtotal\"] = invoice.TotalAmt\n\n        for line in invoice.Line:\n            if line.Description == \"Shipping\":\n\n                order[\"shipping\"] = line.Amount\n\n            elif line.Description == \"Taxes\":\n\n                order[\"tax\"] = line.Amount\n\n            elif line.DetailType == \"SalesItemLineDetail\":\n\n                # order_items[line.Description] = round(float(line.Amount), 2)\n                order_items[line.Description] = line.Amount\n\n        for i in range(len(order[\"items\"])):\n            sku, quantity, _ = order[\"items\"][i]\n            order[\"items\"][i] = (sku, quantity, order_items[sku])\n\n        return order\n"
      },
      {
        "filename": "email_helper.py",
        "code": "import smtplib\nfrom email.message import EmailMessage\nfrom config import SENDER_EMAIL, SENDER_PASSWORD, RECIPIENT_EMAILS\nimport os\nimport getpass\nimport socket\n\n\ndef send_email(subject, body):\n    current_dir = os.getcwd()\n    folder_name = os.path.basename(current_dir)\n    computer_name = socket.gethostname()\n    user_name = getpass.getuser()\n    new_line = \"\\n\"\n    body_with_new_line = (\n        f\"{body}{new_line}{folder_name} on {computer_name} ({user_name})\"\n    )\n    msg = EmailMessage()\n    msg.set_content(body_with_new_line)\n    msg[\"Subject\"] = f\"{subject} : {folder_name}\"\n    msg[\"From\"] = SENDER_EMAIL\n    msg[\"To\"] = \", \".join(RECIPIENT_EMAILS)\n\n    try:\n        with smtplib.SMTP_SSL(\"smtp.gmail.com\", 465) as server:\n            server.login(SENDER_EMAIL, SENDER_PASSWORD)\n            server.send_message(msg)\n        print(\"Email sent successfully.\")\n    except Exception as e:\n        print(f\"Error sending email: {e}\")\n"
      },
      {
        "filename": "exampple_db.py",
        "code": "import pyodbc\nfrom config import create_connection_string, db_config\nfrom decimal_rounding import round_to_decimal\nfrom datetime import datetime\nfrom tqdm import tqdm\n\n\nclass ExampleDb:\n    def __init__(self):\n        try:\n            self.conn = pyodbc.connect(create_connection_string(db_config[\"ExampleDb\"]))\n            self.cursor = self.conn.cursor()\n        except pyodbc.Error as e:\n            print(f\"Error establishing connection to the ExampleDb database: {e}\")\n            raise\n\n    def get_invoice_ready_orders(self):\n        \"\"\"Gets all the untracked orders from the ExampleDb database.\"\"\"\n        try:\n            self.cursor.execute(\n                \"\"\"\n                SELECT   \n                    po.id,     \n                    po.purchase_order_number,\n                    po.sellercloud_order_id,\n                    po.shipping_cost,\n                    po.tracking_number,\n                    po.tracking_date,\n                    po.city,\n                    po.zip,\n                    po.address,\n                    s.code AS state,\n                    c.two_letter_code AS country,\n                    d.code,\n                    d.name,\n                    d.ftp_folder_name,\n                    ff.name AS file_format_name\n                FROM PurchaseOrders po\n                JOIN Dropshippers d ON po.dropshipper_id = d.id\n                JOIN States s ON po.state = s.id\n                JOIN Countries c ON po.country = c.id\n                JOIN DropshipperFileFormats dff ON dff.dropshipper_id = d.id\n                JOIN FileFormats ff ON ff.id = dff.format_id\n                WHERE po.tracking_number IS NOT NULL AND ff.type = 'invoice' AND po.is_invoiced = 0\n                \"\"\"\n            )\n\n            rows = self.cursor.fetchall()\n\n            dropshippers_untracked_orders = {}\n\n            for row in tqdm(rows, desc=\"Getting ready to invoice orders\"):\n                # Creating a tuple to identify the dropshipper\n                dropshipper_info = (row.code, row.ftp_folder_name)\n                items = self._get_invoice_ready_order_items(row.id)\n\n                order = {\n                    \"items\": items,\n                    \"purchase_order_number\": row.purchase_order_number,\n                    \"sellercloud_order_id\": row.sellercloud_order_id,\n                    \"tax\": \"\",  # Because is null\n                    \"shipping\": round_to_decimal(row.shipping_cost),\n                    \"subtotal\": \"\",  # Because is null\n                    \"code\": row.code,\n                    \"tracking_number\": row.tracking_number,\n                    \"ship_date\": row.tracking_date.strftime(\"%Y/%m/%d\"),\n                    \"city\": row.city,\n                    \"state\": row.state,\n                    \"country\": row.country,\n                    \"postal_code\": row.zip,\n                    \"address\": row.address,\n                    \"dropshipper_name\": row.name,\n                }\n                # Making sure that the dropshipper code is included in the order id\n                code_length = len(row.code)\n                if row.purchase_order_number[:code_length] == row.code:\n                    order[\"order_id\"] = row.purchase_order_number\n                else:\n                    order[\"order_id\"] = row.code + row.purchase_order_number\n\n                # Adding the order to the dictionary using the dropshipper info as the key\n                if dropshippers_untracked_orders.get(dropshipper_info):\n                    dropshippers_untracked_orders[dropshipper_info][\"orders\"].append(\n                        order\n                    )\n\n                else:\n                    dropshippers_untracked_orders[dropshipper_info] = {\n                        \"orders\": [order],\n                        # The file format name is used to determine the csv headers\n                        \"file_format_name\": row.file_format_name,\n                    }\n\n            return dropshippers_untracked_orders\n\n        except Exception as e:\n            print(f\"Error while storing purchase orders: {e}\")\n            raise\n\n    def _get_invoice_ready_order_items(self, id):\n        \"\"\"Gets all the untracked order items from the ExampleDb database.\"\"\"\n        try:\n            self.cursor.execute(\n                \"\"\"\n                SELECT\n                    poi.sku,\n                    poi.quantity\n                FROM PurchaseOrderItems poi\n                WHERE poi.purchase_order_id = ?\n                \"\"\",\n                id,\n            )\n            rows = self.cursor.fetchall()\n\n            untracked_order_items = [(row.sku, row.quantity) for row in rows]\n\n            # return untracked_order_items, items_price_total\n            return untracked_order_items\n\n        except Exception as e:\n            print(f\"Error while storing purchase order items: {e}\")\n            raise\n\n    def get_vendor_mapping(self):\n        \"\"\"Gets the vendor mapping from the ExampleDb database\"\"\"\n        try:\n            self.cursor.execute(\n                \"\"\"\n                SELECT\n                    name,\n                    ship_method,\n                    invoice_email,\n                    quickbook_id\n                FROM Dropshippers WHERE code != 'ABS'\n                \"\"\"\n            )\n            rows = self.cursor.fetchall()\n            vendor_mapping = {}\n            for row in rows:\n                vendor_mapping[row.name] = {\n                    \"ship_method\": row.ship_method,\n                    \"email\": row.invoice_email,\n                    \"customer_id\": row.quickbook_id,\n                }\n\n            return vendor_mapping\n\n        except Exception as e:\n            print(f\"Error while getting vendor mapping: {e}\")\n            raise\n\n    def get_invoice_csv_headers(self):\n        \"\"\"Gets the csv headers for the invoice files.\"\"\"\n        try:\n            self.cursor.execute(\n                \"\"\"\n                SELECT \n                    f.name AS file_format_name,\n                    STRING_AGG(fd.header_name, ', ') AS header_names\n                FROM fileformats f \n                JOIN fileformatdetails fd ON fd.format_id = f.id\n                WHERE f.type = 'invoice'\n                GROUP BY f.name\n                ORDER BY f.name;\n                \"\"\"\n            )\n            rows = self.cursor.fetchall()\n            headers = {\n                row.file_format_name: row.header_names.split(\", \") for row in rows\n            }\n            return headers\n        except Exception as e:\n            print(f\"Error while getting csv headers: {e}\")\n            raise\n\n    def update_invoice_status(self, pos_invoiced):\n        \"\"\"Updates the invoice status of the given purchase order number.\"\"\"\n        po_update_data = []\n        items_update_data = []\n\n        for order in pos_invoiced:\n            subtotal = 0\n            for item in order[\"items\"]:\n                sku, quantity, price = item\n                subtotal += price\n                items_update_data.append((price, order[\"purchase_order_number\"], sku))\n            po_update_data.append(\n                (\n                    subtotal,\n                    order[\"shipping\"],\n                    order[\"tax\"],\n                    order[\"subtotal\"],\n                    datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S\"),\n                    order[\"purchase_order_number\"],\n                )\n            )\n\n        try:\n            self.cursor.executemany(\n                \"\"\"\n                UPDATE PurchaseOrders\n                SET \n                subtotal = ?,\n                shipping_cost = ?,\n                tax = ?,\n                total = ?,\n                is_invoiced = 1,\n                invoiced_date = ?\n                WHERE purchase_order_number = ?\n                \"\"\",\n                po_update_data,\n            )\n\n            self.cursor.executemany(\n                \"\"\"\n                UPDATE PurchaseOrderItems\n                SET \n                price = ?\n                WHERE purchase_order_id = (SELECT id FROM PurchaseOrders WHERE purchase_order_number = ?) AND sku = ?\n                \"\"\",\n                items_update_data,\n            )\n\n            self.conn.commit()\n        except Exception as e:\n            print(f\"Error while updating invoice status: {e}\")\n            raise\n\n    def close(self):\n        self.conn.close()\n"
      },
      {
        "filename": "file_handler.py",
        "code": "import os\n\n\nclass FileHandler:\n\n    def __init__(self, report_date):\n        self.report_date = report_date\n\n    DATE_FORMAT = \"%m%d%Y\"\n    TIME_FORMAT = \"%H%M%S\"\n    BASE_DIRECTORY = \"tmp\"\n\n    def save_data_to_file(self, invoice_data_df, ftp_folder_name):\n        \"\"\"Saves the tracking data to a file.\"\"\"\n        if invoice_data_df.empty:\n            return False\n        directory_path = self._create_directory_structure(ftp_folder_name)\n        date_str = self.report_date.strftime(FileHandler.DATE_FORMAT)\n        file_path = f\"{directory_path}\\\\Invoice_{date_str}.csv\"\n\n        try:\n            invoice_data_df.to_csv(file_path, index=False)\n            return file_path\n        except Exception as e:\n            print(f\"Error while saving tracking data to file: {e}\")\n            raise\n\n    def _create_directory_structure(self, ftp_folder_name):\n        \"\"\"Creates the directory structure for the tracking files.\"\"\"\n        datetime_str = self.report_date.strftime(\n            f\"{FileHandler.DATE_FORMAT}_{FileHandler.TIME_FORMAT}\"\n        )\n        dir_path = os.path.join(\n            FileHandler.BASE_DIRECTORY, ftp_folder_name, datetime_str\n        )\n\n        if not os.path.exists(dir_path):\n            os.makedirs(dir_path)\n\n        return dir_path\n"
      },
      {
        "filename": "ftp.py",
        "code": "import os\nimport ftplib\nfrom config import ftp_server\nfrom tqdm import tqdm\nfrom email_helper import send_email\n\n\nclass FTPManager:\n    def __init__(self):\n        self.host = ftp_server[\"server\"]\n        self.username = ftp_server[\"username\"]\n        self.password = ftp_server[\"password\"]\n\n    def upload_files(self, all_paths):\n        \"\"\"Uploads files to both the dropshipper's and the log's folders in the FTP server.\"\"\"\n        try:\n            # Starting connection to FTP\n            self.ftp = ftplib.FTP(self.host)\n            self.ftp.login(self.username, self.password)\n\n            for path in tqdm(all_paths, desc=\"Uploading files to FTP server\"):\n                ftp_folder_name, file_name = self._path_decomposer(path)\n\n                if ftp_folder_name != \"absolute_trade\":\n                    # List of directories to upload the file\n                    ftp_directories = [\n                        f\"dropshipper_logs/invoice_logs/{ftp_folder_name}\",\n                        f\"dropshipper/{ftp_folder_name}/invoices\",\n                    ]\n\n                    for ftp_directory in ftp_directories:\n                        # Reset to the root directory\n                        self.ftp.cwd(\"/\")\n\n                        # Change to the remote directory\n                        self.ftp.cwd(ftp_directory)\n\n                        # Uploading file\n                        with open(path, \"rb\") as local_file:\n                            self.ftp.storbinary(\n                                \"STOR \" + os.path.basename(path), local_file\n                            )\n\n            self.ftp.quit()\n\n        except ftplib.all_errors as e:\n            # Closing\n            self.ftp.quit()\n\n            print(f\"There was an error uploading the invoice files to FTP server: {e}\")\n            paths = \"\\n\".join(all_paths)\n            send_email(\n                \"There was an error uploading the invoice files to FTP server\",\n                f\"The following invoice files were not uploaded to the FTP server, please upload them manually:\\n\\t{paths}\",\n            )\n\n    def _path_decomposer(self, path):\n        \"\"\"Decomposes the path into the FTP folder name and the file name.\"\"\" \"\"\n        path_parts = path.split(\"\\\\\")\n        ftp_folder_name = path_parts[1]\n        file_name = path_parts[-1]\n        return ftp_folder_name, file_name\n"
      },
      {
        "filename": "invoice.py",
        "code": "from config import client_data\nfrom intuitlib.client import AuthClient\nfrom quickbooks import QuickBooks\nfrom quickbooks.objects import (\n    Invoice,\n    SalesItemLineDetail,\n    SalesItemLine,\n    Item,\n    Term,\n    Class,\n    Customer,\n)\nfrom datetime import datetime\nfrom quickbooks.objects.base import Ref, Address, EmailAddress\n\n\ndef format_date(date_str, input_format=\"%m/%d/%Y\", output_format=\"%Y-%m-%d\"):\n    return datetime.strptime(date_str, input_format).strftime(output_format)\n\n\nclass QbInvoice:\n    def __init__(self, current_refresh_token):\n        self.auth_client = AuthClient(\n            client_id=client_data[\"client_id\"],\n            client_secret=client_data[\"client_secret\"],\n            environment=client_data[\"environment\"],\n            redirect_uri=client_data[\"redirect_uri\"],\n        )\n        self.client = QuickBooks(\n            auth_client=self.auth_client,\n            refresh_token=current_refresh_token,\n            company_id=client_data[\"realm_id\"],\n        )\n\n    def _create_sales_item_line(\n        self, sku, quantity, unit_cost, item_ref, class_ref, date\n    ):\n        line_detail = SalesItemLineDetail()\n        line_detail.ServiceDate = date\n        line_detail.UnitPrice = unit_cost\n        line_detail.Qty = quantity\n        line_detail.ItemRef = item_ref\n        line_detail.ClassRef = class_ref\n\n        line = SalesItemLine()\n        line.Amount = str(float(unit_cost) * quantity)\n        line.DetailType = \"SalesItemLineDetail\"\n        line.Description = sku\n        line.SalesItemLineDetail = line_detail\n\n        return line\n\n    def _create_tax_line(self, unit_cost, tax_ref, class_ref, date):\n        line_detail = SalesItemLineDetail()\n        line_detail.ServiceDate = date\n        line_detail.UnitPrice = unit_cost\n        line_detail.Qty = 1\n        line_detail.ItemRef = tax_ref\n        line_detail.ClassRef = class_ref\n\n        line = SalesItemLine()\n        line.Amount = unit_cost * 1\n        line.DetailType = \"SalesItemLineDetail\"\n        line.Description = \"Taxes\"\n        line.SalesItemLineDetail = line_detail\n\n        return line\n\n    def _create_shipping_line(self, unit_cost, shipping_ref, class_ref, date):\n        line_detail = SalesItemLineDetail()\n        line_detail.ServiceDate = date\n        line_detail.UnitPrice = unit_cost\n        line_detail.Qty = 1\n        line_detail.ItemRef = shipping_ref\n        line_detail.ClassRef = class_ref\n        line = SalesItemLine()\n        line.Amount = unit_cost\n        line.DetailType = \"SalesItemLineDetail\"\n        line.Description = \"Shipping\"\n        line.SalesItemLineDetail = line_detail\n\n        return line\n\n    def _prepare_invoice(\n        self, row, line_items, customer_ref, term_ref, ship_method_ref, vendor_mappping\n    ):\n        invoice = Invoice()\n        invoice.CustomerRef = customer_ref\n        invoice.SalesTermRef = term_ref\n        invoice.TrackingNum = row[\"tracking_number\"]\n        invoice.ShipDate = row[\"ship_date\"]\n        invoice.Line = line_items\n        invoice.TxnDate = row[\"ship_date\"]\n        invoice.DocNumber = row[\"order_id\"]\n        invoice.BillEmail = EmailAddress()\n        invoice.BillEmail.Address = vendor_mappping[row[\"dropshipper_name\"]][\"email\"]\n\n        invoice.ShipMethodRef = ship_method_ref\n        invoice.ShipAddr = Address()\n        invoice.ShipAddr.City = row[\"city\"]\n        invoice.ShipAddr.CountrySubDivisionCode = row[\"state\"]\n        invoice.ShipAddr.Country = row[\"country\"]\n        invoice.ShipAddr.PostalCode = row[\"postal_code\"]\n        invoice.ShipAddr.Line1 = row[\"address\"]\n\n        return invoice\n\n    def create_invoice(self, row, vendor_mappping):\n        items = row[\"items\"]\n        date = row[\"ship_date\"]\n\n        item_ref = Item.get(2, qb=self.client).to_ref()\n        tax_ref = Item.get(24, qb=self.client).to_ref()\n        shipping_ref = Item.get(23, qb=self.client).to_ref()\n        class_ref = Class.get(1111, qb=self.client).to_ref()  # Class id placeholder\n\n        line_items = []\n\n        for item in items:\n            sku, quantity, unit_cost = item\n\n            sales_item_line = self._create_sales_item_line(\n                sku, quantity, unit_cost, item_ref, class_ref, date\n            )\n            line_items.append(sales_item_line)\n\n        # adding the tax line\n        line_items.append(self._create_tax_line(row[\"tax\"], tax_ref, class_ref, date))\n        line_items.append(\n            self._create_shipping_line(row[\"shipping\"], shipping_ref, class_ref, date)\n        )\n\n        ship_method_ref = Ref()\n        ship_method_ref.value = vendor_mappping[row[\"dropshipper_name\"]][\"ship_method\"]\n        ship_method_ref.name = vendor_mappping[row[\"dropshipper_name\"]][\"ship_method\"]\n\n        customer_id = vendor_mappping[row[\"dropshipper_name\"]][\"customer_id\"]\n        customer_ref = Customer.get(customer_id, qb=self.client).to_ref()\n        term_ref = Term.get(4, qb=self.client).to_ref()\n        try:\n            invoice = self._prepare_invoice(\n                row,\n                line_items,\n                customer_ref,\n                term_ref,\n                ship_method_ref,\n                vendor_mappping,\n            )\n        except Exception as e:\n            print(e)\n            return False\n        try:\n            invoice.save(qb=self.client)\n            return True\n        except Exception as e:\n            print(f\"Error: {e}\")\n            return False\n\n    def check_exist(self, invoice_number):\n        try:\n            invoice = Invoice.filter(DocNumber=invoice_number, qb=self.client)[0]\n            return invoice\n        except IndexError:\n            return False\n        except Exception as e:\n            print(f\"Error: {e}\")\n            return False\n\n    def delete_invoice(self, invoice: Invoice):\n        try:\n            invoice.delete(qb=self.client)\n            return True\n\n        except IndexError:\n            return False\n        except Exception as e:\n            print(f\"Error: {e}\")\n            return False\n\n    def close(self):\n        self.client.close()\n"
      },
      {
        "filename": "main.py",
        "code": "from exampple_db import ExampleDb\nfrom invoice import QbInvoice\nfrom quick_books_db import QuickBooksDb\nfrom email_helper import send_email\nfrom seller_cloud_data import get_sellercloud_data\nfrom file_handler import FileHandler\nfrom df_creator import DfCreator\nfrom ftp import FTPManager\nimport traceback\nfrom tqdm import tqdm\nfrom datetime import datetime, timedelta\n\n\ndef main():\n    try:\n        # Gettting invoice ready orders that have tracking numbers and\n        # creating an object with the orders grouped by dropshipper\n        ex_db = ExampleDb()\n        invoice_csv_headers = ex_db.get_invoice_csv_headers()\n        vendor_mappping = ex_db.get_vendor_mapping()\n\n        ready_to_invoice_orders = ex_db.get_invoice_ready_orders()\n\n        # Getting the financial data from SellerCloud\n        ready_to_invoice_orders = get_sellercloud_data(ready_to_invoice_orders)\n\n        if not ready_to_invoice_orders:\n            print(\"There are no orders ready to be invoiced\")\n            send_email(\n                \"SellerCloud invoicing ran successfully\",\n                \"There are not orders to invoice.\",\n            )\n            ex_db.close()\n            return\n\n        # Creating the quickbooks api that takes care of making the invoice and sending it\n        qb_db = QuickBooksDb()\n        current_refresh_token = qb_db.get_refresh_token()\n        api = QbInvoice(current_refresh_token)\n\n        # Auto refresfing invoice token\n        if api.client.refresh_token != current_refresh_token:\n            qb_db.update_refresh_token(api.client.refresh_token)\n\n        # Placeholders\n        orders_unable_to_invoice = {}\n        orders_already_invoiced = {}\n        pos_invoiced = []\n        tmp_files_paths = []\n\n        # Report date\n        report_date = datetime.now()  # - timedelta(days=1)\n        f_handler = FileHandler(report_date)\n\n        for dropshipper_info, dropshipper_data in ready_to_invoice_orders.items():\n            # Getting the dropshipper code and the folder name for the FTP server\n            dropshipper_code, ftp_folder_name = dropshipper_info\n\n            # Creating the dataframe that will be used to create the invoice csv file\n            df_creator = DfCreator(invoice_csv_headers, dropshipper_data)\n\n            for order in tqdm(\n                dropshipper_data[\"orders\"],\n                desc=f\"Creating invoices for {dropshipper_code}\",\n            ):\n                # Checking if the order has already been invoiced\n                if not api.check_exist(order[\"order_id\"]):\n                    # Creating new invoice\n                    invoice = api.create_invoice(order, vendor_mappping)\n\n                    # If the invoice is None, it means that there was an error\n                    if not invoice:\n                        orders_unable_to_invoice.setdefault(\n                            dropshipper_code, []\n                        ).append(order[\"purchase_order_number\"])\n                    # If the invoice is not None, it means that the invoice was created successfully\n                    else:\n                        pos_invoiced.append(\n                            (order),\n                        )\n                        # Adding the invoice data to the dataframe\n                        in_file = df_creator.populate_df(order)\n\n                        if not in_file:\n                            # If the invoice was not created correctly, it is deleted\n                            just_created_invoice = api.check_exist(order[\"order_id\"])\n                            api.delete_invoice(just_created_invoice)\n                            orders_unable_to_invoice.setdefault(\n                                dropshipper_code, []\n                            ).append(order[\"purchase_order_number\"])\n\n                # If the order has already been invoiced, it is added to the orders_already_invoiced dictionary\n                else:\n                    orders_already_invoiced.setdefault(dropshipper_code, []).append(\n                        order[\"purchase_order_number\"]\n                    )\n                    # Adding the order to the pos_invoiced list so that the is_invoiced status can be updated\n                    pos_invoiced.append(\n                        (order),\n                    )\n\n            # Creating the tmp folder and saving the invoice data to a csv file\n            file_path = f_handler.save_data_to_file(\n                df_creator.invoice_file_df, ftp_folder_name\n            )\n            if file_path:\n                tmp_files_paths.append(file_path)\n        # Uploading the files to the FTP server\n        if tmp_files_paths:\n            ftp = FTPManager()\n            ftp.upload_files(tmp_files_paths)\n\n        if orders_unable_to_invoice or orders_already_invoiced:\n            # Sending an email to notify of the orders that were unable to be invoiced\n            send_error_report(orders_unable_to_invoice, orders_already_invoiced)\n\n        if pos_invoiced:\n            # Updating the is_invoiced status of the PurchaseOrders table\n            ex_db.update_invoice_status(pos_invoiced)\n\n        send_email(\n            \"SellerCloud invoicing ran successfully\",\n            f\"Dont forget to run the test.\\n\\t{pos_invoiced}\",\n        )\n\n        ex_db.close()\n        qb_db.close()\n\n    except Exception as e:\n        print(f\"There was an error: {e}\")\n        send_email(\"An Error Occurred\", f\"Error: {e}\\n\\n{traceback.format_exc()}\")\n        raise e\n\n\nif __name__ == \"__main__\":\n    main()\n"
      },
      {
        "filename": "quick_books_db.py",
        "code": "import pyodbc\nfrom config import create_connection_string, db_config\n\n\nclass QuickBooksDb:\n    def __init__(self):\n        self.conn = pyodbc.connect(\n            create_connection_string(db_config[\"QuickBooks_ExampleDb\"])\n        )\n        self.cursor = self.conn.cursor()\n\n    def get_refresh_token(self):\n        self.cursor.execute(\"SELECT TOP 1 (refresh_token) FROM keys ORDER BY ID DESC\")\n        return self.cursor.fetchone()[0]\n\n    def update_refresh_token(self, refresh_token):\n        conn = pyodbc.connect(\n            create_connection_string(db_config[\"QuickBooks_ExampleDb\"])\n        )\n        cursor = conn.cursor()\n        cursor.execute(\"INSERT INTO keys (refresh_token) VALUES (?)\", refresh_token)\n        conn.commit()\n        return True\n\n    def close(self):\n        self.conn.close()\n"
      },
      {
        "filename": "seller_cloud_api.py",
        "code": "import requests\nfrom requests.exceptions import HTTPError, Timeout, RequestException\nfrom email_helper import send_email\nfrom urllib.parse import quote\nfrom config import sellercloud_credentials, sellercloud_endpoints\n\n\nclass SellerCloudAPI:\n    \"\"\"\n    Class to handle requests to the Seller Cloud order managing API.\n    It takes a dictionary with the credentials and a dictionary with the endpoints both from config.py.\n    The endpoints dictionary should have the following structure:\n    endpoints = {\n        \"EXAMPLE\": {\n        \"type\": \"post\", \"get\" or \"delete\",\n        \"url\": the url of the endpoint with the placeholders for the url_args in the format {url_arg},\n        \"endpoint_error_message\": the error message fragment to be displayed if the request fails in the format \"while (the action it was performing): \",\n        \"success_message\": the success message to be displayed if the request is successful in the format \"(API name) (action it was performing) successfully!\",\n    },\n    \"\"\"\n\n    def __init__(self):\n        self.data = sellercloud_credentials\n        self.endpoints = sellercloud_endpoints\n        response = self.execute(self.data, \"GET_TOKEN\")\n        self.token = response.json()[\"access_token\"]\n        self.headers = {\"Authorization\": f\"Bearer {self.token}\"}\n\n    def execute(self, data, action):\n        \"\"\"Executes a request to the SellerCloud API.\n        Valid actions are: CREATE_ORDER, ADD_ITEM, GET_PRODUCT, GET_TOTAL, UPDATE_TAX, DELETE_ORDER.\n        The data parameter should be a dictionary with the data to be sent to the API and the url_args to be used in the url in the format:\n        data = {\n            \"url_args\": {\"url_arg1\": \"value1\", \"url_arg2\": \"value2\"...},\n            \"data_key\": \"data_value\"\n            \"data_key2\": \"data_value2\"...,\n        }\n        The url_args are the values that will be used to replace the placeholders in the url like this: {url_arg1} -> value1\n        url_exammple = \"https://url_example.com/{url_arg1}/{url_arg2}\"\n        \"\"\"\n        config = self.endpoints.get(action)\n        if not config:\n            raise ValueError(\"Invalid API action\")\n\n        if action == \"GET_TOKEN\":\n            self.headers = None\n            return self.perform_request(self.data, **config)\n\n        return self.perform_request(data, **config)\n\n    def perform_request(\n        self,\n        data,\n        type,\n        url,\n        endpoint_error_message,\n        success_message,\n    ):\n        \"\"\"Performs a request to the SellerCloud API.\"\"\"\n        error_message = None\n        max_attempts = 3\n        timeout = 1000\n\n        for attempt in range(max_attempts):\n            try:\n                url_args = data.pop(\"url_args\", None)\n\n                if url_args:\n                    formatted_url = self._sanitize_url(url, url_args)\n                else:\n                    formatted_url = url\n\n                request_function = getattr(requests, type)\n\n                response = request_function(\n                    formatted_url, headers=self.headers, json=data, timeout=timeout\n                )\n                break\n            except ConnectionError:\n                if attempt < max_attempts - 1:\n                    continue\n                else:\n                    error_message = (\n                        f\"Connection error occurred {endpoint_error_message}\"\n                    )\n            except HTTPError as http_err:\n                error_message = (\n                    f\"HTTP error occurred {endpoint_error_message}{http_err}\"\n                )\n            except Timeout:\n                error_message = f\"Timeout occurred {endpoint_error_message}\"\n            except RequestException as err:\n                error_message = f\"Other error occurred {endpoint_error_message}{err}\"\n            except Exception as e:\n                error_message = (\n                    f\"An unexpected error occurred {endpoint_error_message}{e}\"\n                )\n\n        if error_message:\n            print(error_message)\n            send_email(\n                \"There was an error executing a request on SellerCloud API : \",\n                error_message,\n            )\n            return None\n        elif response.status_code != 200:\n            print(f\"Error: Received status code {response.status_code}\")\n            return response\n        else:\n            print(success_message)\n            return response\n\n    def _sanitize_url(self, url, url_args):\n        \"\"\"Constructs a URL for a  API request.\"\"\"\n        sanitized_url_args = {k: quote(str(v)) for k, v in url_args.items()}\n        return url.format(**sanitized_url_args)\n"
      },
      {
        "filename": "seller_cloud_data.py",
        "code": "from seller_cloud_api import SellerCloudAPI\nfrom email_helper import send_email\nimport traceback\n\n\ndef get_sellercloud_data(ready_to_invoice_orders):\n    \"\"\"Gets the financial data from SellerCloud for the orders that are ready to be invoiced.\"\"\"\n\n    # Creating the SellerCloudAPI object to get the order data\n    sc_api = SellerCloudAPI()\n\n    # Iterating over the dropshippers NOTE: Using a copy of the ready_to_invoice_orders.items to remove any dropshipper that has no orders\n    for dropshipper_key, dropshipper_data in list(ready_to_invoice_orders.items()):\n\n        # Iterating over the orders to get the order data from SellerCloud NOTE: Using a copy of the orders to remove any order that has issues\n        orders_copy = dropshipper_data[\"orders\"].copy()\n        for order in orders_copy:\n            order_index = dropshipper_data[\"orders\"].index(order)\n            try:\n                # Getting the order data from SellerCloud\n                response = sc_api.execute(\n                    {\"url_args\": {\"order_id\": order[\"sellercloud_order_id\"]}},\n                    \"GET_ORDERS\",\n                )\n                if response.status_code == 200:\n                    sellercloud_order = response.json()\n                    # Adding the financial data at the order level\n                    order[\"tax\"] = sellercloud_order[\"TotalInfo\"][\"Tax\"]\n                    order[\"subtotal\"] = sellercloud_order[\"TotalInfo\"][\"GrandTotal\"]\n                    # Adding the financial data at the item level\n                    for item in order[\"items\"]:\n                        # Keeping the original item data to be able to update the price later\n                        item_index = order[\"items\"].index(item)\n                        sku, quantity = item\n                        for product in sellercloud_order[\"OrderItems\"]:\n                            if product[\"ProductIDOriginal\"] == sku:\n                                item = (sku, quantity, product[\"LineTotal\"] / quantity)\n                                order[\"items\"][item_index] = item\n                                break\n                        # If no price was added to the item, the order is removed from the list\n                        if len(item) != 3:\n                            print(f\"Item {sku} not found in SellerCloud\")\n                            send_email(\n                                f\"Item {sku} on order {order['purchase_order_number']} was not found in SellerCloud\",\n                                \"There is a missmatch on the skus the order has in the database and the ones it has in SellerCloud. No invoice was created.\",\n                            )\n                            dropshipper_data[\"orders\"].pop(order_index)\n                            break\n                # If the order was not found, the order is removed from the list\n                else:\n                    print(\n                        f\"Order {order['purchase_order_number']} not found in SellerCloud\"\n                    )\n                    send_email(\n                        f\"Order {order['purchase_order_number']} not found in SellerCloud\",\n                        f\"The API was not able to retrieve {order['purchase_order_number']} using the sellercloud_id {order['sellercloud_order_id']}. No invoice was created.\",\n                    )\n                    dropshipper_data[\"orders\"].pop(order_index)\n\n            except Exception as e:\n                print(f\"Error: {e}\")\n                send_email(\n                    f\"Unable to get price data from SellerCloud for order {order['purchase_order_number']}\",\n                    f\"An unexpected error occurred. No invoice was created.\\nError: {e}\\n\\n{traceback.format_exc()}\",\n                )\n                dropshipper_data[\"orders\"].pop(order_index)\n\n        # If there are no orders left for the dropshipper, the dropshipper is removed from the list\n        if not dropshipper_data[\"orders\"]:\n            del ready_to_invoice_orders[dropshipper_key]\n\n    return ready_to_invoice_orders\n"
      }
    ],
    "repoLink": "https://github.com/aborroto1984/dropship_order_invoice_report",
    "technologies": [
      // eslint-disable-next-line no-template-curly-in-string
      { name: "Python", icon: `${process.env.PUBLIC_URL}/icons/Python.png`},
      { name: "API", icon: `${process.env.PUBLIC_URL}/icons/API.png`},
      { name: "Azure", icon: `${process.env.PUBLIC_URL}/icons/azure.png` },
      { name: "SQL", icon: `${process.env.PUBLIC_URL}/icons/sql.png` },
      { name: "Git", icon: `${process.env.PUBLIC_URL}/icons/git.png` },
      { name: "QuickBooks", icon: `${process.env.PUBLIC_URL}/icons/quickbooks.webp` },
      { name: "Pandas", icon: `${process.env.PUBLIC_URL}/icons/pandas.png` },
      { name: "Files.com", icon: `${process.env.PUBLIC_URL}/icons/files.png` },
      { name: "SellerCloud", icon: `${process.env.PUBLIC_URL}/icons/sellercloud.png` },
    ]
  },
  {
    "title": "Dropship Order Sellercloud Upload",
    "description": "This project automates order processing, tax calculation, and integration with SellerCloud.",
    "files": [
      {
        "filename": "README.md",
        "code": "# Order Processing and SellerCloud Integration\n\nThis project automates order processing, tax calculation, and integration with SellerCloud.\n\n## Features\n- Retrieves orders from the database and processes them.\n- Validates SKUs and calculates tax rates.\n- Creates and updates orders in SellerCloud.\n- Rounds decimal values for financial accuracy.\n- Sends email notifications for errors and order updates.\n\n## Project Structure\n```\nproject_root/\n├── config.py              # Configuration file for database, API, and email credentials\n├── decimal_rounding.py    # Handles rounding of decimal values\n├── email_helper.py        # Sends email notifications\n├── example_db.py          # Manages database interactions\n├── main.py                # Main script orchestrating the order processing\n├── order_creator.py       # Creates order objects and processes them\n├── sales_tax_api.py       # Fetches tax rates from Zip-Tax API\n├── seller_cloud_api.py    # Interfaces with SellerCloud API\n```\n\n## Installation & Setup\n\n### 1. Clone the Repository\n```bash\ngit clone https://github.com/your-repo/order-processing.git\ncd order-processing\n```\n\n### 2. Install Dependencies\nEnsure you have Python 3 installed, then install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n### 3. Configure the System\nModify `config.py` with your database, FTP, and API credentials.\n\nExample database configuration:\n```python\ndb_config = {\n    \"ExampleDb\": {\n        \"server\": \"your.database.windows.net\",\n        \"database\": \"YourDB\",\n        \"username\": \"your_user\",\n        \"password\": \"your_password\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n    },\n}\n```\nExample email configuration:\n```python\nSENDER_EMAIL = \"your_email@example.com\"\nSENDER_PASSWORD = \"your_email_password\"\n```\n\n## Usage\nRun the main script to start the process:\n```bash\npython main.py\n```\n\n## How It Works\n1. Fetches orders from the database.\n2. Validates and processes SKUs.\n3. Calculates tax rates via the Zip-Tax API.\n4. Creates and updates orders in SellerCloud.\n5. Sends email notifications for errors or missing data.\n\n## Tech Stack\n- Python 3\n- Azure SQL Database (`pyodbc`)\n- SellerCloud API Integration\n- Zip-Tax API for tax calculations\n- Email Notifications (`smtplib`)\n- Decimal rounding for financial accuracy\n\n## Troubleshooting\n- If you encounter database connection issues, ensure `ODBC Driver 17` is installed.\n- If emails fail to send, ensure your SMTP settings allow external authentication.\n- Verify SellerCloud credentials if API requests fail.\n"
      },
      {
        "filename": "main.py",
        "code": "from email_helper import send_email\nfrom order_creator import OrderCreator\nfrom example_db import ExampleDb\nfrom seller_cloud_api import SellerCloudAPI\nimport traceback\n\n\ndef batches_creator(objects, batch_size):\n    \"\"\"Creates batches of objects to be processed.\"\"\"\n    counter = 1\n    container = []\n    try:\n        # It makes batches of 50 skus to send to SellerCloud\n        while True:\n            if len(objects) > batch_size:\n                batch = [objects.pop() for _ in range(batch_size)]\n            else:\n                batch = objects\n                objects = []\n\n            container.append(batch)\n\n            if not objects:\n                print(f\"Done creating batches of {batch_size}.\")\n                return container\n\n            counter += 1\n\n    except Exception as e:\n        print(f\"Error creating batches: {e}\")\n        raise Exception(f\"Error creating batches: {e}\")\n\n\ndef main():\n    try:\n        ex_db = ExampleDb()\n\n        # Getting inventory and sku_alias_set\n        sku_shipping_map = ex_db.get_sku_alias_list()\n\n        # The skus in batch are all the skus that are in the orders that is being processed\n        # This is used to check if the skus are in SellerCloud using less API calls\n        po_objects, skus_in_batch = ex_db.load_purchase_orders_not_in_sellercloud()\n\n        sc_api = SellerCloudAPI()\n        creator = OrderCreator(sc_api, skus_in_batch)\n\n        # Getting the dropshippers information from SellerCloud\n        for id, orders in po_objects.items():\n            response = sc_api.execute(\n                {\"url_args\": {\"customer_id\": id}}, \"GET_CUSTOMERS_BY_ID\"\n            )\n            customer = response.json()\n            for order in orders:\n                order[\"customer\"] = customer\n\n        # Exiting if there are no orders to upload\n        if not po_objects:\n            print(\"No orders to upload.\")\n            return\n\n        for sellercloud_id, orders in po_objects.items():\n            # List of orders that are in SellerCloud and ready to be updated in the database\n            orders_in_sc_not_in_db = {}\n\n            # Batch of orders to be uploaded to SellerCloud, this is to avoid uploading too many orders at once\n            batches = batches_creator(orders, 50)\n\n            for orders in batches:\n                for order in orders[:]:\n                    # Since the order is a copy of the original order, we need to get the index of the original order\n                    index = orders.index(order)\n\n                    # Creating the order object to be uploaded to SellerCloud\n                    order_obj, order_amounts = creator.create_order(\n                        order, sellercloud_id, sku_shipping_map\n                    )\n\n                    # Adding the order_amounts to the order object\n                    orders[index][\"order_amounts\"] = order_amounts\n\n                    # If there are no valid skus, skips the order. Report email was sent in create_order.\n                    if not order_obj:\n                        orders.pop(index)\n                        continue\n\n                    # Adding the order to SellerCloud\n                    response = sc_api.execute(order_obj, \"CREATE_ORDER\")\n\n                    # If the order is in SellerCloud, it is added to the list of orders ready to be updated in the database\n                    if (\n                        response.status_code == 500\n                        and \"already exists\" in response.text\n                    ):\n                        # Saving a reference of the duplicate order to get the sellercloud_id later\n                        orders_in_sc_not_in_db[\n                            order_obj[\"OrderDetails\"][\"OrderSourceOrderID\"]\n                        ] = index\n                        print(\"Order already in SellerCloud\")\n\n                    elif response.status_code == 200:\n                        # Adding the sellercloud_id to the order object\n                        orders[index][\"sellercloud_order_id\"] = response.json()\n                        print(\n                            f\"Order uploaded: {order_obj['OrderDetails']['OrderSourceOrderID']}\"\n                        )\n\n                    else:\n                        unable_to_be_added = orders.pop(index)\n                        send_email(\n                            \"There was an error uploading an order to SellerCloud\",\n                            f\"Order: {unable_to_be_added}\\n\\nError: {response.text}\",\n                        )\n\n                # Getting the sellercloud_ids for the orders that are in SellerCloud but not in the database\n                if orders_in_sc_not_in_db:\n\n                    # NOTE: This is not the sellercloud_order_ids but the OrderSourceOrderIDs\n                    order_ids = list(orders_in_sc_not_in_db.keys())\n\n                    response = sc_api.execute(\n                        {\n                            \"url_args\": {\n                                \"order_ids\": \" ,\".join(order_ids),\n                            }\n                        },\n                        \"GET_SELLERCLOUD_IDS\",\n                    )\n\n                    if response.status_code == 200:\n                        for order in response.json()[\"Items\"]:\n\n                            # Getting the index of the original order\n                            index = orders_in_sc_not_in_db[order[\"OrderSourceOrderID\"]]\n\n                            # Adding the sellercloud_id to the order\n                            orders[index][\"sellercloud_order_id\"] = order[\"ID\"]\n\n                    else:\n                        send_email(\n                            \"There was an error getting the sellercloud_ids from SellerCloud\",\n                            f\"Error: \\n{response.text}\\nOrder IDs: \\n{order_ids}\",\n                        )\n\n                    orders_in_sc_not_in_db.clear()\n\n                if orders:\n                    # Updating the database\n                    ex_db.updating_order_data_in_db(orders)\n\n        ex_db.close()\n\n    except Exception as e:\n        if ex_db:\n            ex_db.close()\n        print(f\"There was an error: {e}\")\n        send_email(\"An Error Occurred\", f\"Error: {e}\\n\\n{traceback.format_exc()}\")\n        raise e\n\n\nif __name__ == \"__main__\":\n    main()\n"
      },
      {
        "filename": "config.py",
        "code": "db_config = {\n    \"ExampleDb\": {\n        \"server\": \"example.database.windows.net\",\n        \"database\": \"ExampleDb\",\n        \"username\": \"example\",\n        \"password\": \"example\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n        \"port\": 1433,  # Default port for SQL Server\n    },\n}\n\n\ndef create_connection_string(server_config):\n    return (\n        f\"DRIVER={server_config['driver']};\"\n        f\"SERVER={server_config['server']};\"\n        f\"PORT={server_config[\"port\"]};DATABASE={server_config['database']};\"\n        f\"UID={server_config['username']};\"\n        f\"PWD={server_config['password']}\"\n    )\n\n\nsellercloud_credentials = {\n    \"Username\": \"username\",\n    \"Password\": \"password\",\n}\n\nsellercloud_base_url = \"https://example_company.api.sellercloud.us/rest/api/\"\n\nsellercloud_endpoints = {\n    \"CREATE_ORDER\": {\n        \"type\": \"post\",\n        \"url\": sellercloud_base_url + \"orders\",\n        \"endpoint_error_message\": \"while creating order in SellerCloud: \",\n        \"success_message\": \"\",\n    },\n    \"GET_TOKEN\": {\n        \"type\": \"post\",\n        \"url\": sellercloud_base_url + \"token\",\n        \"endpoint_error_message\": \"while getting SellerCoud API access token: \",\n        \"success_message\": \"Got SellerCloud API access token successfully!\",\n    },\n    \"GET_SELLERCLOUD_IDS\": {\n        \"type\": \"get\",\n        \"url\": sellercloud_base_url\n        + \"Orders?model.orderSourceOrderIDList={order_ids}&model.pageSize=50\",\n        \"endpoint_error_message\": \"while getting sellercloud_ids from SellerCloud: \",\n        \"success_message\": \"Got sellercloud_ids successfully!\",\n    },\n    \"GET_SELLERCLOUD_SKUS\": {\n        \"type\": \"get\",\n        \"url\": sellercloud_base_url + \"Catalog?model.sKU={skus}&model.pageSize=50\",\n        \"endpoint_error_message\": \"while getting order skus from SellerCloud: \",\n        \"success_message\": \"Got all orders skus  from SellerCloud successfully!\",\n    },\n    \"DELETE_ORDER\": {\n        \"type\": \"delete\",\n        \"url\": sellercloud_base_url + \"Orders/{order_id}\",\n        \"endpoint_error_message\": \"while deleting order in SellerCloud: \",\n        \"success_message\": \"SellerCloud deleted an order successfully!\",\n    },\n    \"GET_CUSTOMERS\": {\n        \"type\": \"get\",\n        \"url\": sellercloud_base_url + \"Customers?model.customerType=1\",\n        \"endpoint_error_message\": \"while getting wholesale customers: \",\n        \"success_message\": \"Got customers successfully!\",\n    },\n    \"GET_CUSTOMERS_BY_ID\": {\n        \"type\": \"get\",\n        \"url\": sellercloud_base_url + \"Customers/{customer_id}\",\n        \"endpoint_error_message\": \"while getting wholesale customers by id: \",\n        \"success_message\": \"Got customers successfully!\",\n    },\n}\n\nzip_tax_api_key = \"zip_tax_api_key\"\nzip_tax_api_url = (\n    \"https://api.zip-tax.com/request/v40?key={api_key}&postalcode={postalcode}\"\n)\n\nSENDER_EMAIL = \"sender_email@domain.com\"\nSENDER_PASSWORD = \"sender_password\"\nRECIPIENT_EMAILS = [\n    \"recipient_email_1@domain.com\",\n    \"recipient_email_2@domain.com\",\n]  # List of emails to send the report\n"
      },
      {
        "filename": "decimal_rounding.py",
        "code": "from decimal import Decimal, ROUND_HALF_UP\n\n\ndef round_to_decimal(number):\n    \"\"\"Round a number to a given precision.\"\"\"\n    decimal_number = Decimal(str(number))\n    rounded_number = decimal_number.quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)\n\n    return float(rounded_number)\n"
      },
      {
        "filename": "email_helper.py",
        "code": "import smtplib\nfrom email.message import EmailMessage\nfrom config import (\n    SENDER_EMAIL,\n    SENDER_PASSWORD,\n    RECIPIENT_EMAILS,\n)\nimport os\nimport getpass\nimport socket\n\n\ndef send_email(subject, body):\n    current_dir = os.getcwd()\n    folder_name = os.path.basename(current_dir)\n    computer_name = socket.gethostname()\n    user_name = getpass.getuser()\n    new_line = \"\\n\"\n    body_with_new_line = (\n        f\"{body}{new_line}{folder_name} on {computer_name} ({user_name})\"\n    )\n    msg = EmailMessage()\n    msg.set_content(body_with_new_line)\n    msg[\"Subject\"] = f\"{subject} : {folder_name}\"\n    msg[\"From\"] = SENDER_EMAIL\n    msg[\"To\"] = \", \".join(RECIPIENT_EMAILS)\n\n    try:\n        with smtplib.SMTP_SSL(\"smtp.gmail.com\", 465) as server:\n            server.login(SENDER_EMAIL, SENDER_PASSWORD)\n            server.send_message(msg)\n        print(\"Email sent successfully.\")\n    except Exception as e:\n        print(f\"Error sending email: {e}\")\n"
      },
      {
        "filename": "example_db.py",
        "code": "from email_helper import send_email\nfrom collections import defaultdict\nfrom datetime import datetime\nimport pyodbc\nfrom config import create_connection_string, db_config\n\n\nclass ExampleDb:\n    def __init__(self):\n        try:\n            \"\"\"Establishes a connection to the Example database\"\"\"\n\n            self.conn = pyodbc.connect(create_connection_string(db_config[\"ExampleDb\"]))\n            self.cursor = self.conn.cursor()\n\n        except pyodbc.Error as e:\n            print(f\"Error establishing connection to the ExampleDb database: {e}\")\n            raise\n\n    def update_cancelled_status(self, order):\n        \"\"\"Updates the is_cancelled status of the purchase order\"\"\"\n\n        try:\n            self.cursor.execute(\n                \"\"\"\n                UPDATE PurchaseOrders\n                SET is_cancelled = 1\n                WHERE purchase_order_number = ?\n                \"\"\",\n                order[\"purchase_order_number\"],\n            )\n\n            self.conn.commit()\n            print(\n                f\"Order {order['purchase_order_number']} was cancelled in ExampleDb database.\"\n            )\n\n        except Exception as e:\n            print(f\"Error while updating is_cancelled status: {e}\")\n            send_email(\n                \"There was an error cancelling the following purchase orders in the database: \",\n                f\"{order}\",\n            )\n\n    def load_purchase_orders_not_in_sellercloud(self):\n        \"\"\"Loads the purchase orders that are not in SellerCloud\"\"\"\n\n        try:\n            # Inserting into PurchaseOrders\n            self.cursor.execute(\n                \"\"\"\n                SELECT\n                    d.sellercloud_customer_id,\n                    d.code as dropshipper_code,\n                    po.id,\n                    po.purchase_order_number,\n                    po.date_added,\n                    po.customer_first_name,\n                    po.customer_last_name,\n                    po.phone,\n                    po.address,\n                    po.city,\n                    s.name as state,\n                    po.zip,\n                    c.two_letter_code as country,\n                    po.dropshipper_id,\n                    te.is_exempt,\n                    d.company_shipping_account as ships_with_company_account,\n                    d.ship_method\n                FROM PurchaseOrders po\n                JOIN Dropshippers d ON po.dropshipper_id = d.id\n                JOIN States s ON po.state = s.id\n                JOIN Countries c ON po.country = c.id\n                JOIN TaxExempt te ON po.dropshipper_id = te.dropshipper_id AND po.state = te.state_id\n                WHERE po.in_sellercloud = 0 AND po.is_cancelled = 0 AND d.code != 'ABS' AND po.date_added > '2024-01-01'\n                \"\"\"\n            )\n            # Getting the purchase orders data\n            rows = self.cursor.fetchall()\n\n            # Getting the column names to use as keys\n            columns = [col[0] for col in self.cursor.description]\n\n            #  Creating object with the purchase orders data\n            po_objects = [dict(zip(columns, row)) for row in rows]\n\n            # Sorting the purchase orders by dropshipper_sellercloud_id\n            orders_by_dropshipper = {}\n            skus_in_batch = []\n\n            for po in po_objects:\n                # Getting the purchase order items\n                self.cursor.execute(\n                    \"\"\"\n                    SELECT\n                        sku,\n                        quantity\n                    FROM PurchaseOrderItems\n                    WHERE purchase_order_id = ?\n                    \"\"\",\n                    po[\"id\"],\n                )\n                # Getting the purchase order items data\n                rows = self.cursor.fetchall()\n                # Getting the column names to use as keys\n                columns = [col[0] for col in self.cursor.description]\n\n                # Creating object with the purchase order items data and a list of skus\n                po_items = []\n\n                for row in rows:\n                    po_items.append(dict(zip(columns, row)))\n                    skus_in_batch.append(row[0])\n\n                # Adding the purchase order items to the purchase order object\n                po[\"items\"] = po_items\n\n                # Get the dropshipper_sellercloud_id from the current object\n                sellercloud_customer_id = po[\"sellercloud_customer_id\"]\n\n                # If this sellercloud_customer_id is not in the dictionary, add it with an empty list\n                if not orders_by_dropshipper.get(sellercloud_customer_id):\n                    orders_by_dropshipper[sellercloud_customer_id] = []\n\n                # Append the current purchase order object to the list of this sellercloud_customer_id\n                orders_by_dropshipper[sellercloud_customer_id].append(po)\n\n            return orders_by_dropshipper, skus_in_batch\n\n        except Exception as e:\n            print(f\"Error while storing purchase orders: {e}\")\n            raise\n\n    def updating_order_data_in_db(self, orders):\n        \"\"\"Updates the in_sellercloud status of the purchase order\"\"\"\n\n        if not self.conn and self.conn.closed:\n            self.conn = pyodbc.connect(create_connection_string(db_config[\"ExampleDb\"]))\n            self.cursor = self.conn.cursor()\n\n        curr_time = datetime.now()\n\n        purchase_orders_data = []\n\n        for order in orders:\n            purchase_orders_data.append(\n                (\n                    curr_time,\n                    order[\"sellercloud_order_id\"],\n                    order[\"order_amounts\"][\"shipping_total\"],\n                    order[\"purchase_order_number\"],\n                )\n            )\n\n        try:\n            # Execute bulk update for PurchaseOrders\n            self.cursor.executemany(\n                \"\"\"\n                UPDATE PurchaseOrders\n                SET in_sellercloud = 1, in_sellercloud_date = ?, sellercloud_order_id = ?, shipping_cost = ?\n                WHERE purchase_order_number = ?\n                \"\"\",\n                purchase_orders_data,\n            )\n\n            self.conn.commit()\n\n        except Exception as e:\n            print(f\"Error while updating in_sellercloud status: {e}\")\n            send_email(\n                \"There was an error updating the following purchase orders in the database after being added to SellerCloud: \",\n                f\"{orders}\",\n            )\n\n    def get_sku_alias_list(self):\n        \"\"\"Gets a list of skus and aliases from the database\"\"\"\n        try:\n            self.cursor.execute(\n                \"\"\"\n                SELECT\n                    sku,\n                    alias,\n                    shipping_cost\n                FROM vProductAndAliases\n                \"\"\"\n            )\n            rows = self.cursor.fetchall()\n\n            # Place holder for the sku and alias set\n            sku_alias_map = defaultdict(list)\n\n            # Place holder for the sku and shipping cost set\n            sku_shipping_map = {}\n\n            for sku, alias, shipping_cost in rows:\n                if not alias:\n                    sku_alias_map[sku].append(None)\n                else:\n                    sku_alias_map[sku].append(alias)\n\n                # Storing the shipping cost for each sku and alias\n                if not sku_shipping_map.get(sku):\n                    sku_shipping_map[sku] = shipping_cost\n                if not sku_shipping_map.get(alias):\n                    sku_shipping_map[alias] = shipping_cost\n\n            return sku_shipping_map\n\n        except Exception as e:\n            print(f\"Error while getting skus and aliases: {e}\")\n            raise\n\n    def get_sellercloud_order_ids(self, purchase_order_numbers=None):\n        \"\"\"Gets the sellercloud order ids for the purchase order numbers\"\"\"\n        try:\n            if purchase_order_numbers:\n                placeholders = \", \".join(\"?\" for _ in purchase_order_numbers)\n                self.cursor.execute(\n                    f\"\"\"\n                    SELECT\n                        sellercloud_order_id,\n                    FROM PurchaseOrders\n                    WHERE purchase_order_number in ({placeholders})\n                    \"\"\",\n                    purchase_order_numbers,\n                )\n                rows = self.cursor.fetchall()\n                columns = [col[0] for col in self.cursor.description]\n                return [dict(zip(columns, row)) for row in rows]\n            else:\n                self.cursor.execute(\n                    \"\"\"\n                    SELECT\n                        sellercloud_order_id\n                    FROM PurchaseOrders\n                    WHERE sellercloud_order_id IS NOT NULL \n                    \"\"\"\n                )\n                rows = self.cursor.fetchall()\n\n                return [row[0] for row in rows]\n\n        except Exception as e:\n            print(f\"Error while getting sellercloud order ids: {e}\")\n            raise\n\n    def close(self):\n        self.cursor.close()\n        self.conn.close()\n"
      },
      {
        "filename": "order_creator.py",
        "code": "from seller_cloud_api import SellerCloudAPI\nfrom config import zip_tax_api_key\nfrom sales_tax_api import SalesTaxApi\nfrom email_helper import send_missing_parts_error_report, send_email\nfrom decimal_rounding import round_to_decimal\n\n\nclass OrderCreator:\n    def __init__(self, sc_api: SellerCloudAPI, skus_in_batch):\n        self.sc_api = sc_api\n        self.t_api = SalesTaxApi(zip_tax_api_key)\n        self.skus_in_sellercloud = self._get_skus_in_sellercloud(skus_in_batch)\n\n    def create_order(self, order, sellercloud_id, sku_shipping_map):\n        \"\"\"Create order objects for SellerCloud and get the order totals.\"\"\"\n        dropshipper_name = order[\"customer\"][\"General\"][\"Name\"]\n        dropshipper_discount = order[\"customer\"][\"OrderOptions\"][\"WholesaleDiscount\"]\n        dropshipper_email = order[\"customer\"][\"General\"][\"Email\"]\n\n        # Making sure the skus are in SellerCloud\n        skus = self._validate_skus(\n            order[\"items\"], order[\"purchase_order_number\"], dropshipper_name\n        )\n\n        # If there are no valid skus, skips the order\n        if not skus:\n            return None, None\n\n        # Formatting the skus to be used in the order object and getting the order's total_price\n        products, order_amounts = self._create_skus(\n            skus,\n            sku_shipping_map,\n            order[\"zip\"],\n            order[\"is_exempt\"],\n            order[\"ships_with_company_account\"],\n            dropshipper_discount,\n            order[\"purchase_order_number\"],\n        )\n\n        if products:\n            # Creating the order id reference\n            code_length = len(order[\"dropshipper_code\"])\n\n            if (\n                order[\"purchase_order_number\"][:code_length]\n                == order[\"dropshipper_code\"]\n            ):\n                order_id = order[\"purchase_order_number\"]\n            else:\n                order_id = order[\"dropshipper_code\"] + order[\"purchase_order_number\"]\n\n            # Preparing shipping details\n            if order[\"ship_method\"] == \"UPS Ground\":\n                shipping_details = {\n                    \"ShippingMethod\": \"UPSGround\",\n                    \"Carrier\": \"UPS\",\n                    \"ShippingFee\": order_amounts[\"shipping_total\"],\n                    \"AllowShippingEvenNotPaid\": True,\n                }\n            elif order[\"ship_method\"] == \"FEDEX Ground HD\":\n                shipping_details = {\n                    \"ShippingMethod\": \"FedExGround\",\n                    \"Carrier\": \"Fedex\",\n                    \"ShippingFee\": order_amounts[\"shipping_total\"],\n                    \"AllowShippingEvenNotPaid\": True,\n                }\n\n            # Creating the order objects\n            order_obj = {\n                \"CustomerDetails\": {\n                    \"ID\": sellercloud_id,\n                    \"Email\": dropshipper_email,\n                    \"FirstName\": dropshipper_name,\n                    \"Business\": dropshipper_name,\n                    \"IsWholesale\": True,\n                },\n                \"OrderDetails\": {\n                    \"CompanyID\": 1,  # Placeholder\n                    \"TaxExempt\": order[\"is_exempt\"],\n                    \"Channel\": 21,\n                    \"OrderSourceOrderID\": order_id,\n                    \"OrderDate\": order[\"date_added\"].strftime(\"%Y-%m-%d %H:%M:%S\"),\n                },\n                \"Products\": products,\n                \"ShippingAddress\": {\n                    \"FirstName\": order[\"customer_first_name\"],\n                    \"LastName\": order[\"customer_last_name\"],\n                    \"Country\": order[\"country\"],\n                    \"City\": order[\"city\"],\n                    \"State\": order[\"state\"],\n                    \"ZipCode\": order[\"zip\"],\n                    \"Address\": order[\"address\"],\n                    \"Phone\": order[\"phone\"],\n                },\n                \"ShippingMethodDetails\": shipping_details,\n            }\n\n            return order_obj, order_amounts\n        else:\n            return None, None\n\n    def _create_skus(\n        self,\n        skus,\n        sku_shipping_map,\n        ships_with_company_account,\n        discount,\n        purchase_order_number,\n    ):\n        \"\"\"Adding the skus to the order object and getting the order totals.\"\"\"\n        shipping_total = 0\n\n        sku_objs = []\n        order_amounts = {\"skus_prices\": {}}\n\n        for sku in skus:\n            # Calculating shipping\n            if ships_with_company_account:\n                if sku[\"sku\"] in sku_shipping_map:\n                    sku_shipping_price = sku_shipping_map[sku[\"sku\"]] * sku[\"quantity\"]\n                    shipping_total += sku_shipping_price\n                else:\n                    send_email(\n                        \"Error Calculating Shipping\",\n                        f\"There was an error calculating shipping for order {purchase_order_number}, sku: {sku['sku']} was not found in the ProductCatalog database.\",\n                    )\n                    return None, None\n            else:\n                shipping_total = 0\n\n            # Adding the sku to the order object\n            sku_objs.append(\n                {\n                    \"ProductID\": sku[\"sku\"],\n                    \"Qty\": sku[\"quantity\"],\n                    \"DiscountValue\": discount,\n                    \"DiscountType\": 1,\n                }\n            )\n\n            # order_amounts[\"skus_prices\"][sku[\"sku\"]] = discounted_amount\n\n        # Creating the order totals\n        order_amounts[\"shipping_total\"] = round_to_decimal(shipping_total)\n\n        return sku_objs, order_amounts\n\n    def _validate_skus(self, skus, purchase_order_number, dropshipper_name):\n        \"\"\"Makes sure the skus are in SellerCloud and returns the prices.\"\"\"\n\n        # Placeholder for the valid and invalid skus\n        valid_skus = []\n        invalid_skus = []\n\n        # Separating the valid and invalid skus\n        for sku in skus:\n            if (\n                sku[\"sku\"] in self.skus_in_sellercloud\n                and self.skus_in_sellercloud[sku[\"sku\"]] > 0\n            ):\n                valid_skus.append(\n                    {\n                        \"sku\": sku[\"sku\"],\n                        \"quantity\": sku[\"quantity\"],\n                        \"unit_price\": self.skus_in_sellercloud[sku[\"sku\"]],\n                    }\n                )\n            else:\n                invalid_skus.append({\"sku\": sku[\"sku\"], \"quantity\": sku[\"quantity\"]})\n\n        # Sending an email with the invalid skus\n        if invalid_skus:\n            skus_str = \"\"\n            missing_price = False\n            for sku in invalid_skus:\n                if (\n                    sku[\"sku\"] in self.skus_in_sellercloud\n                    and self.skus_in_sellercloud[sku[\"sku\"]] <= 0\n                ):\n                    missing_price = True\n\n                skus_str += f\"{sku['sku']} - {sku['quantity']} units\\n\"\n\n            send_missing_parts_error_report(\n                skus_str, purchase_order_number, dropshipper_name, missing_price\n            )\n\n            return None\n\n        return valid_skus\n\n    def _get_skus_in_sellercloud(self, sku_numbers):\n        \"\"\"Checks to see if a batch of skus are in SellerCloud.\"\"\"\n        # NOTE: This only returns the skus that are in SellerCloud\n        skus_in_sellercloud = {}\n        try:\n            # It makes batches of 50 skus to send to SellerCloud\n            while True:\n                if len(sku_numbers) > 50:\n                    batch = [sku_numbers.pop() for _ in range(50)]\n                else:\n                    batch = sku_numbers\n                    sku_numbers = []\n\n                # Using the previously extracted skus to get the skus from SellerCloud\n                check_sku_data = {\"url_args\": {\"skus\": \", \".join(batch)}}\n                response = self.sc_api.execute(check_sku_data, \"GET_SELLERCLOUD_SKUS\")\n\n                # Getting the skus and their prices from SellerCloud response\n                if response and response.json():\n                    for sku in response.json()[\"Items\"]:\n                        skus_in_sellercloud[sku[\"ID\"]] = sku[\"WholeSalePrice\"]\n\n                if not sku_numbers:\n                    return skus_in_sellercloud\n\n        except Exception as e:\n            print(f\"Error getting skus from SellerCloud: {e}\")\n            raise Exception(\"Error getting skus from SellerCloud\")\n\n\n# order_model ------------------------------------------------------------------------------\n\n# {\n#   \"ID\": 0,\n#   \"CustomerDetails\": {\n#     \"ID\": 0,\n#     \"Email\": \"string\",\n#     \"FirstName\": \"string\",\n#     \"LastName\": \"string\",\n#     \"Business\": \"string\",\n#     \"IsWholesale\": true,\n#     \"IgnoreCreditLimit\": true\n#   },\n#   \"OrderDetails\": {\n#     \"CompanyID\": 0,\n#     \"MarketingSource\": 0,\n#     \"SalesRepresentative\": 0,\n#     \"IsCurrencyVisible\": true,\n#     \"CurrencyCode\": 0,\n#     \"CurrencyRateFromUSD\": 0,\n#     \"CurrencyRateToUSD\": 0,\n#     \"TaxExempt\": true,\n#     \"IsQuoteOrder\": true,\n#     \"IsSampleOrder\": true,\n#     \"GiftOrder\": true,\n#     \"Channel\": 0,\n#     \"OrderSourceOrderID\": \"string\",\n#     \"DisableInventoryCount\": true,\n#     \"OrderDate\": \"2024-01-18T15:58:19.011Z\",\n#     \"EbaySellingManagerSalesRecordNumber\": \"string\"\n#   },\n#   \"GiftDetails\": {\n#     \"UseGiftWrap\": true,\n#     \"GiftMessage\": \"string\",\n#     \"GiftWrap\": 0,\n#     \"GiftWrapType\": \"string\"\n#   },\n#   \"Products\": [\n#     {\n#       \"ProductID\": \"string\",\n#       \"ReferenceID\": \"string\",\n#       \"ProductName\": \"string\",\n#       \"SitePrice\": 0,\n#       \"DiscountValue\": 0,\n#       \"DiscountType\": 0,\n#       \"Qty\": 0,\n#       \"LineTaxTotal\": 0,\n#       \"FinalValueFee\": 0,\n#       \"Notes\": \"string\",\n#       \"ShipFromWareHouseID\": 0\n#     }\n#   ],\n#   \"ShippingAddress\": {\n#     \"Business\": \"string\",\n#     \"FirstName\": \"string\",\n#     \"MiddleName\": \"string\",\n#     \"LastName\": \"string\",\n#     \"Country\": \"string\",\n#     \"City\": \"string\",\n#     \"State\": \"string\",\n#     \"Region\": \"string\",\n#     \"ZipCode\": \"string\",\n#     \"Address\": \"string\",\n#     \"Address2\": \"string\",\n#     \"Phone\": \"string\",\n#     \"Fax\": \"string\"\n#   },\n#   \"BillingAddress\": {\n#     \"Business\": \"string\",\n#     \"FirstName\": \"string\",\n#     \"MiddleName\": \"string\",\n#     \"LastName\": \"string\",\n#     \"Country\": \"string\",\n#     \"City\": \"string\",\n#     \"State\": \"string\",\n#     \"Region\": \"string\",\n#     \"ZipCode\": \"string\",\n#     \"Address\": \"string\",\n#     \"Address2\": \"string\",\n#     \"Phone\": \"string\",\n#     \"Fax\": \"string\"\n#   },\n#   \"ShippingMethodDetails\": {\n#     \"Carrier\": \"string\",\n#     \"ShippingMethod\": \"string\",\n#     \"Weight\": {\n#       \"Pounds\": 0,\n#       \"Ounces\": 0\n#     },\n#     \"Dimension\": {\n#       \"Width\": 0,\n#       \"Height\": 0,\n#       \"Length\": 0\n#     },\n#     \"HandlingFee\": 0,\n#     \"ShippingFee\": 0,\n#     \"InsuranceFee\": 0,\n#     \"LockShippingMethod\": true,\n#     \"RushOrder\": true,\n#     \"RequirePinToShip\": true,\n#     \"OtherCarrier\": \"string\",\n#     \"OtherMethod\": \"string\",\n#     \"PromiseDate\": \"2024-01-18T15:58:19.011Z\"\n#   },\n#   \"Notes\": [\n#     {\n#       \"EntityID\": 0,\n#       \"Category\": 0,\n#       \"NoteID\": 0,\n#       \"Note\": \"string\",\n#       \"AuditDate\": \"2024-01-18T15:58:19.011Z\",\n#       \"CreatedBy\": 0,\n#       \"CreatedByName\": \"string\",\n#       \"CreatedByEmail\": \"string\"\n#     }\n#   ]\n# }\n"
      },
      {
        "filename": "sales_tax_api.py",
        "code": "import requests\nfrom email_helper import send_email\n\n\nclass SalesTaxApi:\n    def __init__(self, zip_tax_api_key):\n        self.api_key = zip_tax_api_key\n\n    def get_tax_rate(self, postalcode):\n        if len(postalcode) > 5:\n            postalcode = postalcode[:5]\n\n        url = f\"https://api.zip-tax.com/request/v40?key={self.api_key}&postalcode={postalcode}\"\n        max_attempts = 3\n        timeout = 10\n\n        for attempt in range(max_attempts):\n            try:\n                response = requests.get(url, timeout=timeout)\n\n                return response.json()[\"results\"][0][\"taxSales\"]\n            except ConnectionError as e:\n                if attempt < max_attempts - 1:\n                    continue\n                else:\n                    send_email(\n                        \"Tax Calculation\",\n                        f\"Error getting tax rate for {self.po}-{postalcode}\\n\\n{e}\",\n                    )\n                return 0.0\n            except Exception as e:\n                send_email(\n                    \"Tax Calculation\",\n                    f\"Error getting tax rate for {self.po}-{postalcode}\\n\\n{e}\",\n                )\n                return 0.0\n"
      },
      {
        "filename": "seller_cloud_api.py",
        "code": "import requests\nfrom requests.exceptions import HTTPError, Timeout, RequestException\nfrom email_helper import send_email\nfrom urllib.parse import quote\nfrom config import sellercloud_credentials, sellercloud_endpoints\n\n\nclass SellerCloudAPI:\n    \"\"\"\n    Class to handle requests to the Seller Cloud order managing API.\n    It takes a dictionary with the credentials and a dictionary with the endpoints both from config.py.\n    The endpoints dictionary should have the following structure:\n    endpoints = {\n        \"EXAMPLE\": {\n        \"type\": \"post\", \"get\" or \"delete\",\n        \"url\": the url of the endpoint with the placeholders for the url_args in the format {url_arg},\n        \"endpoint_error_message\": the error message fragment to be displayed if the request fails in the format \"while (the action it was performing): \",\n        \"success_message\": the success message to be displayed if the request is successful in the format \"(API name) (action it was performing) successfully!\",\n    },\n    \"\"\"\n\n    def __init__(self):\n        self.data = sellercloud_credentials\n        self.endpoints = sellercloud_endpoints\n        response = self.execute(self.data, \"GET_TOKEN\")\n        self.token = response.json()[\"access_token\"]\n        self.headers = {\"Authorization\": f\"Bearer {self.token}\"}\n\n    def execute(self, data, action):\n        \"\"\"Executes a request to the SellerCloud API.\n        Valid actions are: CREATE_ORDER, ADD_ITEM, GET_PRODUCT, GET_TOTAL, UPDATE_TAX, DELETE_ORDER.\n        The data parameter should be a dictionary with the data to be sent to the API and the url_args to be used in the url in the format:\n        data = {\n            \"url_args\": {\"url_arg1\": \"value1\", \"url_arg2\": \"value2\"...},\n            \"data_key\": \"data_value\"\n            \"data_key2\": \"data_value2\"...,\n        }\n        The url_args are the values that will be used to replace the placeholders in the url like this: {url_arg1} -> value1\n        url_exammple = \"https://url_example.com/{url_arg1}/{url_arg2}\"\n        \"\"\"\n        config = self.endpoints.get(action)\n        if not config:\n            raise ValueError(\"Invalid API action\")\n\n        if action == \"GET_TOKEN\":\n            self.headers = None\n            return self.perform_request(self.data, **config)\n\n        return self.perform_request(data, **config)\n\n    def perform_request(\n        self,\n        data,\n        type,\n        url,\n        endpoint_error_message,\n        success_message,\n    ):\n        \"\"\"Performs a request to the SellerCloud API.\"\"\"\n        error_message = None\n        max_attempts = 3\n        timeout = 1000\n\n        for attempt in range(max_attempts):\n            try:\n                url_args = data.pop(\"url_args\", None)\n\n                if url_args:\n                    formatted_url = self._sanitize_url(url, url_args)\n                else:\n                    formatted_url = url\n\n                request_function = getattr(requests, type)\n\n                response = request_function(\n                    formatted_url, headers=self.headers, json=data, timeout=timeout\n                )\n                break\n            except ConnectionError:\n                if attempt < max_attempts - 1:\n                    continue\n                else:\n                    error_message = (\n                        f\"Connection error occurred {endpoint_error_message}\"\n                    )\n            except HTTPError as http_err:\n                error_message = (\n                    f\"HTTP error occurred {endpoint_error_message}{http_err}\"\n                )\n            except Timeout:\n                error_message = f\"Timeout occurred {endpoint_error_message}\"\n            except RequestException as err:\n                error_message = f\"Other error occurred {endpoint_error_message}{err}\"\n            except Exception as e:\n                error_message = (\n                    f\"An unexpected error occurred {endpoint_error_message}{e}\"\n                )\n\n        if error_message:\n            print(error_message)\n            send_email(\n                \"There was an error executing a request on SellerCloud API : \",\n                error_message,\n            )\n            return None\n        elif response.status_code != 200:\n            print(f\"Error: Received status code {response.status_code}\")\n            return response\n        else:\n            print(success_message)\n            return response\n\n    def _sanitize_url(self, url, url_args):\n        \"\"\"Constructs a URL for a  API request.\"\"\"\n        sanitized_url_args = {k: quote(str(v)) for k, v in url_args.items()}\n        return url.format(**sanitized_url_args)\n"
      }
    ],
    "repoLink": "https://github.com/aborroto1984/dropship_order_sellercloud_upload",
    "technologies": [
      { name: "Python", icon: `${process.env.PUBLIC_URL}/icons/python.png` },
      { name: "API", icon: `${process.env.PUBLIC_URL}/icons/API.png` },
      { name: "Azure", icon: `${process.env.PUBLIC_URL}/icons/azure.png` },
      { name: "SQL", icon: `${process.env.PUBLIC_URL}/icons/sql.png` },
      { name: "Git", icon: `${process.env.PUBLIC_URL}/icons/git.png` },
      { name: "SellerCloud", icon: `${process.env.PUBLIC_URL}/icons/sellercloud.png` },
    ]
  },
  {
    "title": "Dropship Order Tracking Report",
    "description": "This project automates order tracking, status updates, and integration with SellerCloud.",
    "files": [
      {
        "filename": "README.md",
        "code": "# Order Tracking and Processing System\n\nThis project automates order tracking, status updates, and integration with SellerCloud.\n\n## Features\n- Retrieves untracked orders from the database.\n- Fetches tracking numbers and updates order statuses.\n- Uploads tracking data to an FTP server.\n- Sends email notifications for errors and tracking updates.\n\n## Project Structure\n```\nproject_root/\n├── config.py              # Configuration file for database, API, and email credentials\n├── email_helper.py        # Sends email notifications\n├── example_db.py          # Manages database interactions\n├── file_handler.py        # Handles tracking file creation and storage\n├── ftp.py                 # Uploads tracking files to an FTP server\n├── main.py                # Main script orchestrating order tracking\n├── row_creator.py         # Creates tracking file rows\n├── seller_cloud_api.py    # Interfaces with SellerCloud API\n```\n\n## Installation & Setup\n\n### 1. Clone the Repository\n```bash\ngit clone https://github.com/your-repo/order-tracking.git\ncd order-tracking\n```\n\n### 2. Install Dependencies\nEnsure you have Python 3 installed, then install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n### 3. Configure the System\nModify `config.py` with your database, FTP, and API credentials.\n\nExample database configuration:\n```python\ndb_config = {\n    \"ExampleDb\": {\n        \"server\": \"your.database.windows.net\",\n        \"database\": \"YourDB\",\n        \"username\": \"your_user\",\n        \"password\": \"your_password\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n    },\n}\n```\nExample email configuration:\n```python\nSENDER_EMAIL = \"your_email@example.com\"\nSENDER_PASSWORD = \"your_email_password\"\n```\n\n## Usage\nRun the main script to start the tracking process:\n```bash\npython main.py\n```\n\n## How It Works\n1. Fetches untracked orders from the database.\n2. Retrieves tracking numbers from SellerCloud.\n3. Updates order statuses (e.g., shipped, backordered).\n4. Saves tracking data to a CSV file.\n5. Uploads tracking files to an FTP server.\n6. Sends email notifications for errors or missing tracking data.\n\n## Tech Stack\n- Python 3\n- Azure SQL Database (`pyodbc`)\n- SellerCloud API Integration\n- FTP File Handling (`ftplib`)\n- Email Notifications (`smtplib`)\n\n## Troubleshooting\n- If you encounter database connection issues, ensure `ODBC Driver 17` is installed.\n- If emails fail to send, ensure your SMTP settings allow external authentication.\n"
      },
      {
        "filename": "main.py",
        "code": "from row_creator import RowCreator\nfrom email_helper import send_email\nfrom file_handler import FileHandler\nfrom example_db import ExampleDb\nfrom seller_cloud_api import SellerCloudAPI\nimport traceback\nfrom ftp import FTPManager\nfrom tqdm import tqdm\n\n\ndef batches_creator(objects, batch_size):\n    \"\"\"Creates batches of objects to be processed.\"\"\"\n    counter = 1\n    container = []\n    try:\n        # It makes batches of 50 skus to send to SellerCloud\n        while True:\n            if len(objects) > batch_size:\n                batch = [objects.pop() for _ in range(batch_size)]\n            else:\n                batch = objects\n                objects = []\n\n            container.append(batch)\n\n            if not objects:\n                print(f\"Done creating batches of {batch_size}.\")\n                return container\n\n            counter += 1\n\n    except Exception as e:\n        print(f\"Error creating batches: {e}\")\n        raise Exception(f\"Error creating batches: {e}\")\n\n\ndef map_order_status(order_status):\n    if order_status == -1:\n        order_status = \"Cancelled\"\n    elif order_status == 200:\n        order_status = \"OnHold\"\n    elif order_status == 100:\n        order_status = \"ProblemOrder\"\n    else:\n        order_status = None\n\n    return order_status\n\n\ndef get_sellercloud_order(sellercloud_orders_ids):\n    \"\"\"Checks to see if a batch of skus are in SellerCloud.\"\"\"\n    # NOTE: This only returns the skus that are in SellerCloud\n    sc_api = SellerCloudAPI()\n    sellercloud_orders = {}\n    try:\n        # It makes batches of 50 sellercloud_orders_ids to send to SellerCloud\n        batches = batches_creator(sellercloud_orders_ids, 50)\n        for batch in batches:\n            # Using the previously extracted sellercloud_orders_ids to get the orders from SellerCloud\n            check_sku_data = {\"url_args\": {\"order_ids\": \", \".join(batch)}}\n            response = sc_api.execute(check_sku_data, \"GET_ORDERS\")\n\n            # Getting the orders status and tracking number\n            if response.status_code == 200:\n                for order in response.json()[\"Items\"]:\n                    sellercloud_orders[order[\"ID\"]] = {\n                        \"order_status\": map_order_status(order[\"StatusCode\"]),\n                        \"tracking_number\": order[\"TrackingNumber\"],\n                        \"tracking_date\": order[\"ShipDate\"],\n                    }\n\n        return sellercloud_orders\n\n    except Exception as e:\n        print(f\"Error getting skus from SellerCloud: {e}\")\n        raise Exception(\"Error getting orders from SellerCloud\")\n\n\ndef main():\n    try:\n        # Instantiating the classes\n        d_db = ExampleDb()\n        handler = FileHandler()\n        row_creator = RowCreator()\n        ftp = FTPManager()\n\n        # Getting the untracked orders from the database\n        untracked_orders, sellercloud_orders_ids = d_db.get_untracked_orders()\n\n        sellercloud_orders = get_sellercloud_order(sellercloud_orders_ids)\n\n        if not sellercloud_orders:\n            print(\"There are no untracked orders\")\n            return\n\n        # Placeholder for all the paths of the files created in the tmp folder\n        all_paths = []\n\n        dropshipper_codes = list(untracked_orders.keys())\n\n        for dropshipper_code in dropshipper_codes:\n            # Getting the orders for the current dropshipper\n            orders = untracked_orders[dropshipper_code]\n\n            # Placeholder for all the rows created for the current dropshipper data\n            all_rows = []\n\n            for order in tqdm(\n                orders[:], desc=f\"Getting tracking for {dropshipper_code}\"\n            ):\n                # Getting the tracking number and status for the current order\n                order_status_and_shipping = sellercloud_orders[\n                    order[\"sellercloud_order_id\"]\n                ]\n\n                # Turning on the is_cancelled or is_backorder status if needed\n                # and sending an email if the order has a problem status\n                if order_status_and_shipping[\"order_status\"] == \"Cancelled\":\n                    d_db.turning_on_is_cancelled_status(order[\"purchase_order_number\"])\n                elif order_status_and_shipping[\"order_status\"] == \"OnHold\":\n                    d_db.turning_on_is_backorder_status(order[\"purchase_order_number\"])\n                elif order_status_and_shipping[\"order_status\"] == \"ProblemOrder\":\n                    send_email(\n                        \"There is an order with a problem in SellerCloud\",\n                        f\"Order {order['sellercloud_order_id']} has a problem order status\",\n                    )\n\n                # Getting the tracking number\n                if order_status_and_shipping[\"tracking_number\"]:\n                    tracking_number = order_status_and_shipping[\"tracking_number\"]\n                    tracking_date = order_status_and_shipping[\"tracking_date\"]\n                else:\n                    orders.remove(order)\n                    print(\n                        f\"Order {order['purchase_order_number']} has no tracking number.\"\n                    )\n                    continue\n\n                # Storing the tracking number in the order\n                order[\"tracking_number\"] = tracking_number\n                order[\"tracking_date\"] = tracking_date\n\n                # Creating the tracking objects and rows\n                if tracking_number:\n                    rows = row_creator.create_tracking_objects(\n                        order[\"purchase_order_number\"],\n                        order[\"ship_method\"],\n                        tracking_number,\n                        order[\"items\"],\n                    )\n\n                    # Store the rows in the placeholder\n                    all_rows.extend(rows)\n\n            if all_rows:\n                # Saving the tracking data to a file\n                file_path = handler.save_tracking_data_to_file(\n                    all_rows, order[\"ftp_folder_name\"]\n                )\n\n                # Store the path in the placeholder\n                all_paths.append(file_path)\n\n            if not orders:\n                del untracked_orders[dropshipper_code]\n                print(f\"No orders from {dropshipper_code} were tracked.\")\n\n        orders_processed = []\n        if untracked_orders:\n            # Saving the tracking information to the database\n            d_db.save_tracking_data(untracked_orders)\n\n            if all_paths:\n                # Uploading the files to the ftp server\n                ftp.upload_files(all_paths)\n                pass\n\n            for orders in tqdm(\n                untracked_orders.values(), desc=\"Getting data to send email.\"\n            ):\n                for order in orders:\n                    orders_processed.append(order[\"sellercloud_order_id\"])\n\n        send_email(\n            \"Sellercloud tracking report ran successfully\",\n            f\"Orders processed {orders_processed}\",\n        )\n\n    except Exception as e:\n        print(f\"There was an error: {e}\")\n        send_email(\"An Error Occurred\", f\"Error: {e}\\n\\n{traceback.format_exc()}\")\n        raise e\n\n\nif __name__ == \"__main__\":\n    main()\n"
      },
      {
        "filename": "config.py",
        "code": "db_config = {\n    \"ExampleDb\": {\n        \"server\": \"example.database.windows.net\",\n        \"database\": \"ExampleDb\",\n        \"username\": \"example\",\n        \"password\": \"example\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n        \"port\": 1433,  # Default port for SQL Server\n    },\n}\n\n\ndef create_connection_string(server_config):\n    return (\n        f\"DRIVER={server_config['driver']};\"\n        f\"SERVER={server_config['server']};\"\n        f\"PORT={server_config[\"port\"]};DATABASE={server_config['database']};\"\n        f\"UID={server_config['username']};\"\n        f\"PWD={server_config['password']}\"\n    )\n\n\nsellercloud_credentials = {\n    \"Username\": \"username\",\n    \"Password\": \"password\",\n}\n\nsellercloud_base_url = \"https://example_company.api.sellercloud.us/rest/api/\"\n\n\nsellercloud_endpoints = {\n    \"GET_TOKEN\": {\n        \"type\": \"post\",\n        \"url\": \"https://example_company.api.sellercloud.us/rest/api/token\",\n        \"endpoint_error_message\": \"while getting SellerCoud API access token: \",\n        \"success_message\": \"Got SellerCloud API access token successfully!\",\n    },\n    \"GET_ORDERS\": {\n        \"type\": \"get\",\n        \"url\": \"https://example_company.api.sellercloud.us/rest/api/Orders?model.orderIDs={order_ids}&model.pageSize=50\",\n        \"endpoint_error_message\": \"while getting orders from SellerCloud: \",\n        \"success_message\": \"Got orders successfully!\",\n    },\n}\n\nftp_server = {\n    \"server\": \"ftp.example.com\",\n    \"username\": \"example\",\n    \"password\": \"password\",\n}\n\nzip_tax_api_key = \"zip_tax_api_key\"\nzip_tax_api_url = (\n    \"https://api.zip-tax.com/request/v40?key={api_key}&postalcode={postalcode}\"\n)\n\nSENDER_EMAIL = \"sender_email@domain.com\"\nSENDER_PASSWORD = \"sender_password\"\nRECIPIENT_EMAILS = [\n    \"recipient_email_1@domain.com\",\n    \"recipient_email_2@domain.com\",\n]  # List of emails to send the report\n"
      },
      {
        "filename": "email_helper.py",
        "code": "import smtplib\nfrom email.message import EmailMessage\nfrom config import SENDER_EMAIL, SENDER_PASSWORD, RECIPIENT_EMAILS\nimport os\nimport getpass\nimport socket\n\n\ndef send_email(subject, body):\n    current_dir = os.getcwd()\n    folder_name = os.path.basename(current_dir)\n    computer_name = socket.gethostname()\n    user_name = getpass.getuser()\n    new_line = \"\\n\"\n    body_with_new_line = (\n        f\"{body}{new_line}{folder_name} on {computer_name} ({user_name})\"\n    )\n    msg = EmailMessage()\n    msg.set_content(body_with_new_line)\n    msg[\"Subject\"] = f\"{subject} : {folder_name}\"\n    msg[\"From\"] = SENDER_EMAIL\n    msg[\"To\"] = \", \".join(RECIPIENT_EMAILS)\n\n    try:\n        with smtplib.SMTP_SSL(\"smtp.gmail.com\", 465) as server:\n            server.login(SENDER_EMAIL, SENDER_PASSWORD)\n            server.send_message(msg)\n        print(\"Email sent successfully.\")\n    except Exception as e:\n        print(f\"Error sending email: {e}\")\n"
      },
      {
        "filename": "example_db.py",
        "code": "import pyodbc\nfrom config import create_connection_string, db_config\nfrom email_helper import send_email\nfrom tqdm import tqdm\n\n\nclass ExampleDb:\n    def __init__(self):\n        try:\n            self.conn = pyodbc.connect(\n                create_connection_string(db_config[\"ExampleDb\"]),\n            )\n            self.cursor = self.conn.cursor()\n        except pyodbc.Error as e:\n            print(f\"Error establishing connection to the ExampleDb database: {e}\")\n            raise\n\n    def get_untracked_orders(self):\n        \"\"\"Gets all the untracked orders from the ExampleDb database.\"\"\"\n        try:\n            self.cursor.execute(\n                \"\"\"\n                SELECT   \n                    po.id,     \n                    po.purchase_order_number,\n                    po.sellercloud_order_id,\n                    d.code\n                FROM PurchaseOrders po\n                JOIN Dropshippers d ON po.dropshipper_id = d.id\n                WHERE po.is_cancelled = 0 AND po.in_sellercloud = 1 AND po.tracking_number IS NULL AND d.code = 'ABS'\n                \"\"\"\n            )\n            rows = self.cursor.fetchall()\n\n            # Placeholder\n            dropshippers_untracked_orders = {}\n            sellercloud_order_ids = []\n\n            for row in tqdm(rows, desc=\"Getting untracked orders\"):\n                sellercloud_order_ids.append(str(row.sellercloud_order_id))\n\n                order = {\n                    \"purchase_order_number\": row.purchase_order_number,\n                    \"sellercloud_order_id\": row.sellercloud_order_id,\n                }\n\n                if dropshippers_untracked_orders.get(row.code):\n                    dropshippers_untracked_orders[row.code].append(order)\n\n                else:\n                    dropshippers_untracked_orders[row.code] = [order]\n\n            return dropshippers_untracked_orders, sellercloud_order_ids\n\n        except Exception as e:\n            print(f\"Error while getting untracked orders: {e}\")\n            raise\n\n    def turning_on_is_cancelled_status(self, purchase_order_number):\n        \"\"\"Updates the is_cancelled status to 1 in the ExampleDb database.\"\"\"\n        try:\n            self.cursor.execute(\n                \"\"\"\n                UPDATE PurchaseOrders\n                SET is_cancelled = '1'\n                WHERE purchase_order_number = ?\n                \"\"\",\n                purchase_order_number,\n            )\n            self.conn.commit()\n\n        except Exception as e:\n            print(f\"Error while updating backorder status: {e}\")\n            send_email(\n                \"There was an error while updating is_cancelled status: \",\n                f\"Please update the is_cancelled status in the PurchaseOrders table, to 1 for the purchase order {purchase_order_number} manually.\",\n            )\n\n    def turning_on_is_backorder_status(self, purchase_order_number):\n        \"\"\"Updates the is_cancelled status to 1 in the ExampleDb database.\"\"\"\n        try:\n            self.cursor.execute(\n                \"\"\"\n                UPDATE PurchaseOrders\n                SET is_backorder = '1'\n                WHERE purchase_order_number = ?\n                \"\"\",\n                purchase_order_number,\n            )\n            self.conn.commit()\n\n        except Exception as e:\n            print(f\"Error while updating backorder status: {e}\")\n            send_email(\n                \"There was an error while updating is_cancelled status: \",\n                f\"Please update the is_cancelled status in the PurchaseOrders table, to 1 for the purchase order {purchase_order_number} manually.\",\n            )\n\n    def save_tracking_data(self, untracked_orders):\n        \"\"\"Saves the tracking data to the database.\"\"\"\n        po_and_tracking = []\n        for orders in tqdm(untracked_orders.values(), desc=\"Saving tracking data\"):\n            for order in orders:\n                if order.get(\"tracking_number\"):\n                    po_and_tracking.append(\n                        (\n                            order[\"tracking_number\"],\n                            order[\"purchase_order_number\"],\n                        )\n                    )\n\n        try:\n            self.cursor.executemany(\n                \"\"\"\n                UPDATE PurchaseOrders\n                SET tracking_number = ?\n                WHERE purchase_order_number = ?\n                \"\"\",\n                po_and_tracking,\n            )\n            self.conn.commit()\n\n        except Exception as e:\n            print(f\"Error while updating tracking number: {e}\")\n            send_email(\n                \"There was an error while adding the tracking number to an order: \",\n                f\"Please add the tracking number in the PurchaseOrders table, for the following purchase orders manually:\\n\\t{po_and_tracking}.\",\n            )\n\n    def close(self):\n        \"\"\"Closes the connection to the database.\"\"\"\n        self.cursor.close()\n        self.conn.close()\n"
      },
      {
        "filename": "file_handler.py",
        "code": "from datetime import datetime\nimport os\nimport pandas as pd\n\n\nclass FileHandler:\n    DATE_FORMAT = \"%m%d%Y\"\n    TIME_FORMAT = \"%H%M%S\"\n    BASE_DIRECTORY = \"tmp\"\n\n    @staticmethod\n    def save_tracking_data_to_file(all_rows, ftp_folder_name):\n        \"\"\"Saves the tracking data to a file.\"\"\"\n        tracking_data_df = pd.DataFrame(all_rows)\n        directory_path = FileHandler._create_directory_structure(ftp_folder_name)\n        date_str = datetime.today().strftime(FileHandler.DATE_FORMAT)\n        time_str = datetime.today().strftime(FileHandler.TIME_FORMAT)\n        file_path = f\"{directory_path}\\ASN_{date_str}_{time_str}.csv\"\n\n        try:\n            tracking_data_df.to_csv(file_path, index=False)\n            return file_path, tracking_data_df\n        except Exception as e:\n            print(f\"Error while saving tracking data to file: {e}\")\n            raise\n\n    @staticmethod\n    def _create_directory_structure(ftp_folder_name):\n        \"\"\"Creates the directory structure for the tracking files.\"\"\"\n        datetime_str = datetime.today().strftime(\n            f\"{FileHandler.DATE_FORMAT}_{FileHandler.TIME_FORMAT}\"\n        )\n        dir_path = os.path.join(\n            FileHandler.BASE_DIRECTORY, ftp_folder_name, datetime_str\n        )\n\n        if not os.path.exists(dir_path):\n            os.makedirs(dir_path)\n\n        return dir_path\n"
      },
      {
        "filename": "ftp.py",
        "code": "import os\nimport ftplib\nfrom config import ftp_server\nfrom tqdm import tqdm\nfrom email_helper import send_email\n\n\nclass FTPManager:\n    def __init__(self):\n        self.host = ftp_server[\"server\"]\n        self.username = ftp_server[\"username\"]\n        self.password = ftp_server[\"password\"]\n\n    def upload_files(self, all_paths):\n        \"\"\"Uploads files to both the dropshipper's and the log's folders in the FTP server.\"\"\"\n        try:\n            # Starting connection to FTP\n            self.ftp = ftplib.FTP(self.host)\n            self.ftp.login(self.username, self.password)\n\n            for path_tupple in tqdm(all_paths, desc=\"Uploading files to FTP server\"):\n                path = path_tupple[0]\n                ftp_folder_name, file_name = self._path_decomposer(path)\n\n                if ftp_folder_name != \"absolute_trade\":\n                    # List of directories to upload the file\n                    ftp_directories = [\n                        f\"dropshipper_logs/tracking_logs/{ftp_folder_name}\",\n                        f\"dropshipper/{ftp_folder_name}/tracking\",\n                    ]\n\n                    for ftp_directory in ftp_directories:\n                        # Reset to the root directory\n                        self.ftp.cwd(\"/\")\n\n                        # Change to the remote directory\n                        self.ftp.cwd(ftp_directory)\n\n                        # Uploading file\n                        with open(path, \"rb\") as local_file:\n                            self.ftp.storbinary(\n                                \"STOR \" + os.path.basename(path), local_file\n                            )\n\n            self.ftp.quit()\n\n        except ftplib.all_errors as e:\n            # Closing\n            self.ftp.quit()\n\n            print(\n                f\"There was an error uploading the tracking files to the FTP server: {e}\"\n            )\n            send_email(\n                f\"There was an error uploading the following tracking files to FTP server: \\n\\t{all_paths}\"\n            )\n\n    def _path_decomposer(self, path):\n        \"\"\"Decomposes the path into the FTP folder name and the file name.\"\"\" \"\"\n        path_parts = path.split(\"\\\\\")\n        ftp_folder_name = path_parts[1]\n        file_name = path_parts[-1]\n        return ftp_folder_name, file_name\n"
      },
      {
        "filename": "row_creator.py",
        "code": "from datetime import datetime\n\n# This is a dictionary of the shipping methods that Jolt uses.\n# The keys can be found by using the Get All Shipping Methods Postman request.\n# Custom shipping methods can be added here.\nshipping_methods = {\n    \"UPS Ground\": {\"name\": \"UPS\", \"code\": \"UPS\"},\n    \"FEDEX Ground HD\": {\"name\": \"FedEx\", \"code\": \"FEDHD\"},\n}\n\n\nclass RowCreator:\n    @staticmethod\n    def create_tracking_objects(po, ship_method, tracking_number, items):\n        \"\"\"Creates the tracking_obj and rows for the tracking file.\"\"\"\n        rows = []\n\n        carrier_name = shipping_methods[ship_method][\"name\"]\n        ship_method_code = shipping_methods[ship_method][\"code\"]\n        ship_date = RowCreator._format_ship_date()\n\n        for item in items:\n            tracking_obj = {\n                \"po_number\": po,\n                \"sku\": item[\"sku\"],\n                \"quantity\": item[\"quantity\"],\n                \"carrier_name\": carrier_name,\n                \"ship_method\": \"Ground\",\n                \"ship_method_code\": ship_method_code,\n                \"ship_date\": ship_date,\n                \"tracking_number\": tracking_number,\n            }\n            rows.append(tracking_obj)\n\n        return rows\n\n    @staticmethod\n    def _format_ship_date():\n        \"\"\"Formats the ship date as YYYY-MM-DD.\"\"\"\n        return datetime.today().strftime(\"%Y-%m-%d\")\n"
      },
      {
        "filename": "seller_cloud_api.py",
        "code": "import requests\nfrom requests.exceptions import HTTPError, Timeout, RequestException\nfrom email_helper import send_email\nfrom urllib.parse import quote\nfrom config import sellercloud_credentials, sellercloud_endpoints\n\n\nclass SellerCloudAPI:\n    \"\"\"\n    Class to handle requests to the Seller Cloud order managing API.\n    It takes a dictionary with the credentials and a dictionary with the endpoints both from config.py.\n    The endpoints dictionary should have the following structure:\n    endpoints = {\n        \"EXAMPLE\": {\n        \"type\": \"post\", \"get\" or \"delete\",\n        \"url\": the url of the endpoint with the placeholders for the url_args in the format {url_arg},\n        \"endpoint_error_message\": the error message fragment to be displayed if the request fails in the format \"while (the action it was performing): \",\n        \"success_message\": the success message to be displayed if the request is successful in the format \"(API name) (action it was performing) successfully!\",\n    },\n    \"\"\"\n\n    def __init__(self):\n        self.data = sellercloud_credentials\n        self.endpoints = sellercloud_endpoints\n        self.token = self.execute(self.data, \"GET_TOKEN\").json()[\"access_token\"]\n        self.headers = {\"Authorization\": f\"Bearer {self.token}\"}\n\n    def execute(self, data, action):\n        \"\"\"Executes a request to the Jolt API.\n        Valid actions are: CREATE_ORDER, ADD_ITEM, GET_PRODUCT, GET_TOTAL, UPDATE_TAX, DELETE_ORDER.\n        The data parameter should be a dictionary with the data to be sent to the API and the url_args to be used in the url in the format:\n        data = {\n            \"url_args\": {\"url_arg1\": \"value1\", \"url_arg2\": \"value2\"...},\n            \"data_key\": \"data_value\"\n            \"data_key2\": \"data_value2\"...,\n        }\n        The url_args are the values that will be used to replace the placeholders in the url like this: {url_arg1} -> value1\n        url_exammple = \"https://url_example.com/{url_arg1}/{url_arg2}\"\n        \"\"\"\n        config = self.endpoints.get(action)\n        if not config:\n            raise ValueError(\"Invalid API action\")\n\n        if action == \"GET_TOKEN\":\n            self.headers = None\n            return self.perform_request(self.data, **config)\n\n        return self.perform_request(data, **config)\n\n    def perform_request(\n        self,\n        data,\n        type,\n        url,\n        endpoint_error_message,\n        success_message,\n    ):\n        \"\"\"Performs a request to the Jolt API.\"\"\"\n        error_message = None\n        max_attempts = 3\n        timeout = 10\n\n        for attempt in range(max_attempts):\n            try:\n                url_args = data.pop(\"url_args\", None)\n\n                if url_args:\n                    formatted_url = self._sanitize_url(url, url_args)\n                else:\n                    formatted_url = url\n\n                request_function = getattr(requests, type)\n\n                response = request_function(\n                    formatted_url, headers=self.headers, json=data, timeout=timeout\n                )\n                break\n            except ConnectionError:\n                if attempt < max_attempts - 1:\n                    continue\n                else:\n                    error_message = (\n                        f\"Connection error occurred {endpoint_error_message}\"\n                    )\n            except HTTPError as http_err:\n                error_message = (\n                    f\"HTTP error occurred {endpoint_error_message}{http_err}\"\n                )\n            except Timeout:\n                error_message = f\"Timeout occurred {endpoint_error_message}\"\n            except RequestException as err:\n                error_message = f\"Other error occurred {endpoint_error_message}{err}\"\n            except Exception as e:\n                error_message = (\n                    f\"An unexpected error occurred {endpoint_error_message}{e}\"\n                )\n\n        if error_message:\n            print(error_message)\n            send_email(\n                \"There was an error executing a request on SellerCloud API : \",\n                error_message,\n            )\n            return None\n        elif response.status_code != 200:\n            print(f\"Error: Received status code {response.status_code}\")\n            return response\n        else:\n            print(success_message)\n            return response\n\n    def _sanitize_url(self, url, url_args):\n        \"\"\"Constructs a URL for a Jolt API request.\"\"\"\n        sanitized_url_args = {k: quote(str(v)) for k, v in url_args.items()}\n        return url.format(**sanitized_url_args)\n"
      }
    ],
    "repoLink": "https://github.com/aborroto1984/dropship_order_tracking_report",
    "technologies": [
      { name: "Python", icon: `${process.env.PUBLIC_URL}/icons/python.png` },
      { name: "API", icon: `${process.env.PUBLIC_URL}/icons/API.png` },
      { name: "Azure", icon: `${process.env.PUBLIC_URL}/icons/azure.png` },
      { name: "SQL", icon: `${process.env.PUBLIC_URL}/icons/sql.png` },
      { name: "Git", icon: `${process.env.PUBLIC_URL}/icons/git.png` },
      { name: "SellerCloud", icon: `${process.env.PUBLIC_URL}/icons/sellercloud.png` },
      { name: "Files.com", icon: `${process.env.PUBLIC_URL}/icons/files.png` },
      { name: "Pandas", icon: `${process.env.PUBLIC_URL}/icons/pandas.png` },
    ]
  },
  {
    "title": "PDF Invoice Report",
    "description": "This project automates invoice generation, SellerCloud order tracking, and email notifications.",
    "files": [
      {
        "filename": "README.md",
        "code": "# PDF Invoice Generation and Order Management System\n\nThis project automates invoice generation, SellerCloud order tracking, and email notifications.\n\n## Features\n- Retrieves orders that require PDF invoices.\n- Fetches order details from SellerCloud.\n- Generates PDF invoices using ReportLab.\n- Sends generated invoices via email.\n- Updates order statuses in the database.\n\n## Project Structure\n```\nproject_root/\n├── config.py              # Configuration file for database, API, and email credentials\n├── email_helper.py        # Sends email notifications with PDFs\n├── example_db.py          # Manages database interactions\n├── helpers.py             # Utility functions for batching and order fetching\n├── main.py                # Main script orchestrating invoice generation\n├── pdf_creator.py         # Generates PDF invoices\n├── seller_cloud_api.py    # Interfaces with SellerCloud API\n├── spinner.py             # Provides a terminal-based progress spinner\n```\n\n## Installation & Setup\n\n### 1. Clone the Repository\n```bash\ngit clone https://github.com/your-repo/pdf-invoice-generator.git\ncd pdf-invoice-generator\n```\n\n### 2. Install Dependencies\nEnsure you have Python 3 installed, then install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n### 3. Configure the System\nModify `config.py` with your database, FTP, and API credentials.\n\nExample database configuration:\n```python\ndb_config = {\n    \"ExampleDb\": {\n        \"server\": \"your.database.windows.net\",\n        \"database\": \"YourDB\",\n        \"username\": \"your_user\",\n        \"password\": \"your_password\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n    },\n}\n```\nExample email configuration:\n```python\nSENDER_EMAIL = \"your_email@example.com\"\nSENDER_PASSWORD = \"your_email_password\"\nPDF_RECIPIENT_EMAILS = [\"recipient@example.com\"]\n```\n\n## Usage\nRun the main script to start the invoice generation process:\n```bash\npython main.py\n```\n\n## How It Works\n1. Fetches orders needing PDF invoices from the database.\n2. Retrieves order details from SellerCloud.\n3. Generates formatted PDF invoices.\n4. Sends invoices via email.\n5. Updates order statuses in the database.\n\n## Tech Stack\n- Python 3\n- ReportLab (PDF generation)\n- Azure SQL Database (`pyodbc`)\n- SellerCloud API Integration\n- Email Notifications (`smtplib`)\n\n## Troubleshooting\n- If you encounter database connection issues, ensure `ODBC Driver 17` is installed.\n- If emails fail to send, ensure your SMTP settings allow external authentication.\n- Verify SellerCloud credentials if API requests fail.\n"
      },
      {
        "filename": "main.py",
        "code": "from email_helper import send_email, send_pdf_invoice\nfrom example_db import ExampleDb\nfrom seller_cloud_api import SellerCloudAPI\nfrom helpers import Helpers\nfrom pdf_creator import InvoiceGenerator\nfrom datetime import datetime\nfrom spinner import Spinner\nimport traceback\nimport os\n\n\ndef main():\n    try:\n        spinner = Spinner()\n        rc_db = ExampleDb()\n        h = Helpers()\n        sc_api = SellerCloudAPI()\n        tmp_folder = \"tmp_pdfs\"\n\n        orders_without_pdf, ref_numbers = rc_db.get_orders_without_pdf(spinner)\n\n        if not ref_numbers:\n            print(\"No orders without PDFs found. Exiting script.\")\n            return\n\n        sellercloud_orders = h.get_sellercloud_order(ref_numbers, sc_api, spinner)\n\n        pdf_creator = InvoiceGenerator()\n        all_pdf_data = pdf_creator.create_pdf_data(\n            orders_without_pdf, sellercloud_orders, spinner\n        )\n\n        all_pdf_invoices = []\n\n        spinner.start(\"Generating PDF invoices...\")\n        if not os.path.exists(tmp_folder):\n            os.makedirs(tmp_folder)\n\n        for pdf_data in all_pdf_data:\n            file_name = f\"{tmp_folder}\\\\{pdf_data['reference']}_{datetime.now().strftime('%m_%d_%Y')}.pdf\"\n            pdf_creator.generate_invoice(pdf_data, file_name)\n            rc_db.update_status(pdf_data[\"reference\"])\n            all_pdf_invoices.append(file_name)\n        spinner.stop()\n\n        spinner.start(\"Sending PDF invoices...\")\n        send_pdf_invoice(\n            \"Company PDF Invoices\",\n            \"Attached are the latest Company PDF invoices.\",\n            all_pdf_invoices,\n        )\n        spinner.stop()\n\n        spinner.start(\"Cleaning up PDF invoices...\")\n        for pdf in all_pdf_invoices:\n            pdf_creator.delete_invoice(pdf)\n        spinner.stop()\n\n        print(\"Script completed successfully.\")\n\n    except Exception as e:\n        print(\n            f\"An error occurred while running the Dropship SellerCloud API script. Error message: {str(e)}\"\n        )\n        send_email(\"An Error Occurred\", f\"Error: {e}\\n\\n{traceback.format_exc()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
      },
      {
        "filename": "config.py",
        "code": "db_config = {\n    \"ExampleDb\": {\n        \"server\": \"example.database.windows.net\",\n        \"database\": \"ExampleDb\",\n        \"username\": \"example\",\n        \"password\": \"example\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n        \"port\": 1433,  # Default port for SQL Server\n    },\n}\n\n\ndef create_connection_string(server_config):\n    return (\n        f\"DRIVER={server_config['driver']};\"\n        f\"SERVER={server_config['server']};\"\n        f\"PORT={server_config[\"port\"]};DATABASE={server_config['database']};\"\n        f\"UID={server_config['username']};\"\n        f\"PWD={server_config['password']}\"\n    )\n\n\nsellercloud_credentials = {\n    \"Username\": \"username\",\n    \"Password\": \"password\",\n}\n\nsellercloud_base_url = \"https://example_company.api.sellercloud.us/rest/api/\"\n\nsellercloud_endpoints = {\n    \"GET_SELLERCLOUD_ORDER\": {\n        \"type\": \"get\",\n        \"url\": sellercloud_base_url\n        + \"Orders?model.orderSourceOrderIDList={ref_id}&model.pageSize=50\",\n        \"endpoint_error_message\": \"while getting sellercloud_id from SellerCloud: \",\n        \"success_message\": \"Sucess!!\",\n    },\n    \"GET_TOKEN\": {\n        \"type\": \"post\",\n        \"url\": sellercloud_base_url + \"token\",\n        \"endpoint_error_message\": \"while getting SellerCoud API access token: \",\n        \"success_message\": \"Got SellerCloud API access token successfully!\",\n    },\n}\n\nSENDER_EMAIL = \"sender_email@domain.com\"\nSENDER_PASSWORD = \"sender_password\"\nRECIPIENT_EMAILS = [\n    \"recipient_email_1@domain.com\",\n    \"recipient_email_2@domain.com\",\n]  # List of emails to send the report\nPDF_RECIPIENT_EMAILS = [\n    \"pdf_recipient_email_1@domain.com\",\n    \"pdf_recipient_email_2@domain.com\",\n]  # List of emails to send the PDF invoice report\n"
      },
      {
        "filename": "email_helper.py",
        "code": "import smtplib\nfrom email.message import EmailMessage\nfrom config import SENDER_EMAIL, SENDER_PASSWORD, RECIPIENT_EMAILS, PDF_RECIPIENT_EMAILS\nimport os\nimport getpass\nimport socket\n\n\ndef send_email(subject, body):\n    current_dir = os.getcwd()\n    folder_name = os.path.basename(current_dir)\n    computer_name = socket.gethostname()\n    user_name = getpass.getuser()\n    new_line = \"\\n\"\n    body_with_new_line = (\n        f\"{body}{new_line}{folder_name} on {computer_name} ({user_name})\"\n    )\n    msg = EmailMessage()\n    msg.set_content(body_with_new_line)\n    msg[\"Subject\"] = f\"{subject} : {folder_name}\"\n    msg[\"From\"] = SENDER_EMAIL\n    msg[\"To\"] = \", \".join(RECIPIENT_EMAILS)\n\n    try:\n        with smtplib.SMTP_SSL(\"smtp.gmail.com\", 465) as server:\n            server.login(SENDER_EMAIL, SENDER_PASSWORD)\n            server.send_message(msg)\n        print(\"Email sent successfully.\")\n    except Exception as e:\n        print(f\"Error sending email: {e}\")\n\n\ndef send_pdf_invoice(subject, body, pdf_paths):\n    \"\"\"\n    Send an email with multiple PDF attachments.\n\n    Args:\n        subject (str): The email subject.\n        body (str): The email body content.\n        pdf_paths (list): List of file paths for the PDFs to be attached.\n    \"\"\"\n    # Create the email message\n    msg = EmailMessage()\n    msg.set_content(body)\n    msg[\"Subject\"] = subject\n    msg[\"From\"] = SENDER_EMAIL\n    msg[\"To\"] = \", \".join(PDF_RECIPIENT_EMAILS)\n\n    # Loop through the list of PDF paths and attach each one\n    for pdf_path in pdf_paths:\n        try:\n            file_name = os.path.basename(pdf_path)\n            with open(pdf_path, \"rb\") as pdf_file:\n                pdf_data = pdf_file.read()\n                # Add the PDF as an attachment\n                msg.add_attachment(\n                    pdf_data, maintype=\"application\", subtype=\"pdf\", filename=file_name\n                )\n        except FileNotFoundError:\n            print(f\"Error: PDF file not found at path: {pdf_path}\")\n        except Exception as e:\n            print(f\"Error attaching the file: {pdf_path}. Error: {e}\")\n            return  # Exit the function if any file fails\n\n    # Connect to the SMTP server and send the email\n    try:\n        with smtplib.SMTP_SSL(\"smtp.gmail.com\", 465) as server:\n            server.login(SENDER_EMAIL, SENDER_PASSWORD)\n            server.send_message(msg)\n        print(\"Email sent successfully.\")\n    except Exception as e:\n        print(f\"Error sending email: {e}\")\n"
      },
      {
        "filename": "example_db.py",
        "code": "import pyodbc\nfrom config import create_connection_string, db_config\nfrom datetime import datetime\nfrom spinner import Spinner\n\n\nclass ExampleDb:\n    def __init__(self):\n        try:\n            self.conn = pyodbc.connect(create_connection_string(db_config[\"ExampleDb\"]))\n            self.cursor = self.conn.cursor()\n        except pyodbc.Error as e:\n            print(f\"Error establishing connection to the ExampleDb database: {e}\")\n            raise\n\n    def get_orders_without_pdf(self, spinner: Spinner):\n        \"\"\"Gets the orders from the database that need to be created in SellerCloud.\"\"\"\n        try:\n            spinner.start(\"Getting orders without PDF invoices...\")\n            self.cursor.execute(\n                \"\"\"\n                SELECT * FROM ProductionOrders WHERE pdf_invoiced = 0 AND in_sellercloud = 1\n                \"\"\"\n            )\n\n            orders = {}\n\n            for row in self.cursor.fetchall():\n                po_number = row.po_number.strip()\n                po_reference = row.ref_number.strip()\n                prod_date = row.prod_date.strftime(\"%m/%d/%Y\")\n\n                if po_reference not in orders:\n                    orders[po_reference] = {\n                        \"prod_date\": prod_date,\n                        \"pos\": [\n                            {\n                                \"po_number\": po_number,\n                                \"rc_part\": row.rc_part,\n                                \"alias_part\": row.alias_part,\n                                \"qty\": row.qty,\n                            }\n                        ],\n                    }\n                else:\n                    orders[po_reference][\"pos\"].append(\n                        {\n                            \"po_number\": po_number,\n                            \"rc_part\": row.rc_part,\n                            \"alias_part\": row.alias_part,\n                            \"qty\": row.qty,\n                        }\n                    )\n\n        except Exception as e:\n            spinner.stop()\n            print(f\"Error while checking for duplicate: {e}\")\n            raise\n\n        ref_numbers = list(orders.keys())\n        spinner.stop()\n        return orders, ref_numbers\n\n    def update_status(self, ref_number):\n        \"\"\"Updates the order in the database.\"\"\"\n        try:\n            self.cursor.execute(\n                \"\"\"\n                UPDATE ProductionOrders SET\n                    pdf_invoiced = 1, \n                    pdf_invoiced_date = ?\n                WHERE ref_number = ?\n                \"\"\",\n                datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                ref_number,\n            )\n\n            self.conn.commit()\n\n        except Exception as e:\n            print(f\"Error while updating orders: {e}\")\n            raise\n\n    def close(self):\n        self.cursor.close()\n        self.conn.close()\n"
      },
      {
        "filename": "helpers.py",
        "code": "from seller_cloud_api import SellerCloudAPI\nfrom email_helper import send_email\nfrom spinner import Spinner\n\n\nclass Helpers:\n    def __init__(self):\n        pass\n\n    def batches_creator(self, objects, batch_size):\n        \"\"\"Creates batches of objects to be processed.\"\"\"\n        counter = 1\n        container = []\n        try:\n            # It makes batches of 50 skus to send to SellerCloud\n            while True:\n                if len(objects) > batch_size:\n                    batch = [objects.pop() for _ in range(batch_size)]\n                else:\n                    batch = objects\n                    objects = []\n\n                container.append(batch)\n\n                if not objects:\n                    print(f\"Done creating batches of {batch_size}.\")\n                    return container\n\n                counter += 1\n\n        except Exception as e:\n            print(f\"Error creating batches: {e}\")\n            raise Exception(f\"Error creating batches: {e}\")\n\n    def failure_reporting(self, where, sc_order_ids):\n        string = \"\\n\".join(sc_order_ids)\n        send_email(f\"Error {where}\", f\"Error {where} for SellerCloud ids: \\n{string}.\")\n\n    def get_sellercloud_order(\n        self, ref_numbers, sc_api: SellerCloudAPI, spinner: Spinner\n    ):\n        try:\n            spinner.start(\"Getting SellerCloud order ids...\")\n            sellercloud_orders = {}\n            for ref_number in ref_numbers:\n                response = sc_api.execute(\n                    {\n                        \"url_args\": {\n                            \"ref_id\": ref_number,\n                        }\n                    },\n                    \"GET_SELLERCLOUD_ORDER\",\n                )\n                if response.status_code == 200:\n                    sellercloud_orders[ref_number] = response.json()[\"Items\"][0]\n                else:\n                    print(f\"Error: Received status code {response.status_code}\")\n                    return None\n\n            spinner.stop()\n            return sellercloud_orders\n        except Exception as e:\n            spinner.stop()\n            print(\n                f\"There was an error getting the sellercloud order id for PO: {ref_number}: {e}\"\n            )\n            return None\n"
      },
      {
        "filename": "pdf_creator.py",
        "code": "from reportlab.lib.pagesizes import LETTER\nfrom reportlab.lib import colors\nfrom reportlab.platypus import (\n    SimpleDocTemplate,\n    Table,\n    TableStyle,\n    Paragraph,\n    Spacer,\n    Image,\n    KeepTogether,\n)\nfrom reportlab.lib.styles import getSampleStyleSheet\nfrom reportlab.lib.enums import TA_RIGHT, TA_LEFT, TA_CENTER\nfrom reportlab.lib.units import inch\nimport os\nfrom spinner import Spinner\nimport re\n\n\nclass InvoiceGenerator:\n    def __init__(self, logo_path, filename=\"invoice.pdf\"):\n        self.logo_path = logo_path\n        self.filename = filename\n        self.styles = getSampleStyleSheet()\n\n        # Define separate styles for different alignments\n        self.left_aligned_style = self.styles[\"Normal_Left\"]\n        self.left_aligned_style.alignment = TA_LEFT\n\n        self.right_aligned_style = self.styles[\"Normal_Right\"]\n        self.right_aligned_style.alignment = TA_RIGHT\n\n        self.center_aligned_style = self.styles[\"Normal_Center\"]\n        self.center_aligned_style.alignment = TA_CENTER\n\n        self.ship_to_address = \"Name Last\\nShip to Address\\nCity, State, Zip, Country\"\n        self.bill_to_address = \"Name Last\\nBill to Address\\nCity, State, Zip, Country\"\n        self.company_address = (\n            \"Selling Company Address\\nCity, State Zip\\nPhone: (555) 555-5555\"\n        )\n\n    def _get_logo(self):\n        \"\"\"Add logo or a placeholder\"\"\"\n        if self.logo_path:\n            return Image(self.logo_path, width=73, height=73)\n        return Paragraph(\"\", self.styles[\"Normal\"])  # Empty if no logo\n\n    def _get_header_table(self, invoice_data):\n        \"\"\"Create the header table with logo, addresses, and invoice info\"\"\"\n        bill_to = f\"BILL TO:<br/>{self.bill_to_address}\"\n\n        left_column_data = [\n            [self._get_logo()],\n            [Paragraph(self.company_address, self.left_aligned_style)],\n            [Spacer(1, 12)],\n            [Paragraph(bill_to, self.left_aligned_style)],\n        ]\n        left_column_table = Table(left_column_data, colWidths=[2.5 * inch])\n\n        # Invoice title and right-aligned content\n        tittle_right_aligned_style = self.styles[\"Title\"]\n        tittle_right_aligned_style.alignment = TA_RIGHT\n        tittle_right_aligned_style.fontSize = 28\n\n        invoice_title = \"<b>INVOICE</b>\"\n        date_and_reference = (\n            f\"REFERENCE#: {invoice_data['reference']}<br/>DATE: {invoice_data['date']}\"\n        )\n        ship_to = f\"SHIP TO:<br/>{self.ship_to_address}\"\n\n        right_column_data = [\n            [Spacer(1, 12)],\n            [Paragraph(invoice_title, tittle_right_aligned_style)],\n            [Spacer(1, 12)],\n            [Paragraph(date_and_reference, self.right_aligned_style)],\n            [Spacer(1, 12)],\n            [Paragraph(ship_to, self.right_aligned_style)],\n        ]\n        right_column_table = Table(right_column_data, colWidths=[2.5 * inch])\n\n        center_column_data = [[\"\"], [\"\"], [Spacer(1, 12)], [\"\"]]\n        center_column_table = Table(center_column_data, colWidths=[2.5 * inch])\n\n        # Combine left and right columns into a header table\n        header_table = Table(\n            [[left_column_table, center_column_table, right_column_table]],\n            colWidths=[2.5 * inch, 2.2 * inch, 2.8 * inch],\n        )\n        header_table.setStyle(TableStyle([(\"VALIGN\", (0, 0), (-1, -1), \"TOP\")]))\n        return header_table\n\n    def _create_invoice_items_table(self, invoice_data):\n        \"\"\"Create the invoice items table\"\"\"\n        data = [[\"PO#\", \"PART#\", \"QTY\", \"PART NAME\", \"UNIT PRICE\", \"LINE TOTAL\"]]\n\n        total_qty = 0\n        total_line_sum = 0.0\n\n        for item in invoice_data[\"items\"]:\n            data.append(\n                [\n                    item[\"po\"],\n                    item[\"part\"],\n                    item[\"qty\"],\n                    Paragraph(\n                        item[\"description\"], self.left_aligned_style\n                    ),  # Left-aligned PART NAME\n                    Paragraph(\n                        f\"${item['unit_price']:,.2f}\", self.center_aligned_style\n                    ),  # Center-aligned UNIT PRICE\n                    Paragraph(\n                        f\"${item['line_total']:,.2f}\", self.center_aligned_style\n                    ),  # Right-aligned LINE TOTAL\n                ]\n            )\n            total_qty += item[\"qty\"]\n            total_line_sum += item[\"line_total\"]\n\n        # Define column widths\n        colWidths = [\n            0.8 * inch,\n            1.0 * inch,\n            0.8 * inch,\n            2.8 * inch,\n            1.0 * inch,\n            1.0 * inch,\n        ]\n\n        # Create the main table for the items\n        table = Table(data, colWidths=colWidths)\n\n        # Style the table\n        table.setStyle(\n            TableStyle(\n                [\n                    (\"TEXTCOLOR\", (0, 0), (-1, 0), colors.black),\n                    (\"ALIGN\", (0, 0), (-1, -1), \"CENTER\"),\n                    (\"VALIGN\", (0, 0), (-1, -1), \"MIDDLE\"),\n                    (\"FONTNAME\", (0, 0), (-1, 0), \"Helvetica-Bold\"),\n                    (\n                        \"GRID\",\n                        (0, 0),\n                        (-1, -1),\n                        1,\n                        colors.black,\n                    ),  # Grid for all rows\n                ]\n            )\n        )\n\n        return table  # Just return the main table\n\n    def generate_invoice(self, invoice_data, filename):\n        \"\"\"Generate the PDF invoice\"\"\"\n        pdf = SimpleDocTemplate(filename, pagesize=LETTER)\n        elements = []\n\n        # Add the header section\n        elements.append(self._get_header_table(invoice_data))\n        elements.append(Spacer(1, 12))\n\n        # Add the invoice items table\n        elements.append(self._create_invoice_items_table(invoice_data))\n        elements.append(Spacer(1, 12))\n\n        # Adding TOTAL and other rows in a separate summary table\n        summary_data = [\n            [\n                \"Total\",\n                \"\",\n                sum(item[\"qty\"] for item in invoice_data[\"items\"]),\n                \"\",\n                \"SUBTOTAL\",\n                f\"${sum(item['line_total'] for item in invoice_data['items']):,.2f}\",\n            ],\n            [\"\", \"\", \"\", \"\", \"FEES\", f\"${invoice_data['fees']:,.2f}\"],\n            [\n                \"\",\n                \"\",\n                \"\",\n                \"\",\n                \"TOTAL\",\n                f\"${(sum(item['line_total'] for item in invoice_data['items']) + invoice_data['fees']):,.2f}\",\n            ],\n        ]\n\n        colWidths = [\n            0.8 * inch,\n            1.0 * inch,\n            0.8 * inch,\n            2.8 * inch,\n            1.0 * inch,\n            1.0 * inch,\n        ]\n\n        summary_table = Table(summary_data, colWidths=colWidths)\n\n        # Style the summary table\n        summary_table.setStyle(\n            TableStyle(\n                [\n                    (\"ALIGN\", (0, -3), (-1, -1), \"CENTER\"),\n                    (\n                        \"GRID\",\n                        (0, -3),\n                        (6, -3),\n                        1,\n                        colors.black,\n                    ),  # Grid for the last rows\n                    (\n                        \"GRID\",\n                        (5, -2),\n                        (6, -1),\n                        1,\n                        colors.black,\n                    ),  # Grid for the last rows'\n                    (\"SPAN\", (0, -3), (1, -3)),\n                ]\n            )\n        )\n\n        # Add summary table wrapped in KeepTogether to prevent splitting\n        elements.append(KeepTogether(summary_table))\n\n        # Build the PDF\n        pdf.build(elements)\n        print(f\"Invoice generated: {filename}\")\n\n    def delete_invoice(self, filename):\n        \"\"\"Delete the PDF invoice\"\"\"\n        try:\n            os.remove(filename)\n            print(f\"Invoice deleted: {filename}\")\n        except FileNotFoundError:\n            print(f\"Error: File not found at path: {filename}\")\n\n    def create_pdf_data(self, orders_without_pdf, sellercloud_orders, spinner: Spinner):\n        \"\"\"Parse the data to be used in the invoice\"\"\"\n        spinner.start(\"Creating PDF data...\")\n        all_data = []\n        for po_reference, reference_data in orders_without_pdf.items():\n            sellercloud_data = {\n                item[\"ProductIDOriginal\"]: {\n                    \"description\": item[\"ProductName\"],\n                    \"unit_price\": item[\"PricePerCase\"],\n                    \"line_total\": item[\"LineTotal\"],\n                }\n                for item in sellercloud_orders[po_reference][\"Items\"]\n            }\n            items, subtotal = self._create_items(\n                sellercloud_data, reference_data[\"pos\"]\n            )\n            invoice_data = {\n                \"reference\": self._convert_string_safe(po_reference),\n                \"date\": reference_data[\"prod_date\"],\n                \"items\": items,\n                \"subtotal\": subtotal,\n                \"fees\": 0.00,\n                \"total\": subtotal,\n            }\n\n            all_data.append(invoice_data)\n\n        spinner.stop()\n        return all_data\n\n    def _create_items(self, sellercloud_data, parts):\n        items = []\n        subtotal = 0.00\n        for part in parts:\n            item = {\n                \"po\": part[\"po_number\"],\n                \"part\": part[\"rc_part\"],\n                \"qty\": part[\"qty\"],\n                \"description\": sellercloud_data[part[\"rc_part\"]][\"description\"],\n                \"unit_price\": sellercloud_data[part[\"rc_part\"]][\"unit_price\"],\n                \"line_total\": sellercloud_data[part[\"rc_part\"]][\"line_total\"],\n            }\n            subtotal += item[\"line_total\"]\n            items.append(item)\n\n        return items, subtotal\n\n    def _convert_string_safe(self, input_str):\n        # Use regular expression to keep only letters and numbers\n        return re.sub(r\"[^A-Za-z0-9]\", \"\", input_str)\n\n\n# Example usage -----------------------------------------------------------------------------------------------------------\n\n# invoice_data = {\n#     \"reference\": \"TTTTTTT\",\n#     \"date\": \"5/17/2023\",\n#     \"items\": [\n#         {\n#             \"po\": \"67648\",\n#             \"part\": \"RD2-68018\",\n#             \"qty\": 40,\n#             \"description\": \"Here is the description of the part\",\n#             \"unit_price\": 52.99,\n#             \"line_total\": 2119.60,\n#         },\n#         {\n#             \"po\": \"68018\",\n#             \"part\": \"RD2-68019\",\n#             \"qty\": 50,\n#             \"description\": \"Here is the description of the part\",\n#             \"unit_price\": 52.99,\n#             \"line_total\": 2649.50,\n#         },\n#         # Add more items...\n#     ],\n#     \"subtotal\": 43087.95,\n#     \"fees\": 0.00,\n#     \"total\": 43087.95,\n# }\n\n\n# invoice = InvoiceGenerator(logo_path=\"logo.png\")\n# invoice.generate_invoice(invoice_data, \"invoice.pdf\")\n"
      },
      {
        "filename": "seller_cloud_api.py",
        "code": "import requests\nfrom requests.exceptions import HTTPError, Timeout, RequestException\nfrom email_helper import send_email\nfrom urllib.parse import quote\nfrom config import sellercloud_credentials, sellercloud_endpoints\n\n\nclass SellerCloudAPI:\n    \"\"\"\n    Class to handle requests to the Seller Cloud order managing API.\n    It takes a dictionary with the credentials and a dictionary with the endpoints both from config.py.\n    The endpoints dictionary should have the following structure:\n    endpoints = {\n        \"EXAMPLE\": {\n        \"type\": \"post\", \"get\" or \"delete\",\n        \"url\": the url of the endpoint with the placeholders for the url_args in the format {url_arg},\n        \"endpoint_error_message\": the error message fragment to be displayed if the request fails in the format \"while (the action it was performing): \",\n        \"success_message\": the success message to be displayed if the request is successful in the format \"(API name) (action it was performing) successfully!\",\n    },\n    \"\"\"\n\n    def __init__(self):\n        self.data = sellercloud_credentials\n        self.endpoints = sellercloud_endpoints\n        response = self.execute(self.data, \"GET_TOKEN\")\n        self.token = response.json()[\"access_token\"]\n        self.headers = {\"Authorization\": f\"Bearer {self.token}\"}\n\n    def execute(self, data, action):\n        \"\"\"Executes a request to the SellerCloud API.\n        Valid actions are: CREATE_ORDER, ADD_ITEM, GET_PRODUCT, GET_TOTAL, UPDATE_TAX, DELETE_ORDER.\n        The data parameter should be a dictionary with the data to be sent to the API and the url_args to be used in the url in the format:\n        data = {\n            \"url_args\": {\"url_arg1\": \"value1\", \"url_arg2\": \"value2\"...},\n            \"data_key\": \"data_value\"\n            \"data_key2\": \"data_value2\"...,\n        }\n        The url_args are the values that will be used to replace the placeholders in the url like this: {url_arg1} -> value1\n        url_exammple = \"https://url_example.com/{url_arg1}/{url_arg2}\"\n        \"\"\"\n        config = self.endpoints.get(action)\n        if not config:\n            raise ValueError(\"Invalid API action\")\n\n        if action == \"GET_TOKEN\":\n            self.headers = None\n            return self.perform_request(self.data, **config)\n\n        return self.perform_request(data, **config)\n\n    def perform_request(\n        self,\n        data,\n        type,\n        url,\n        endpoint_error_message,\n        success_message,\n    ):\n        \"\"\"Performs a request to the SellerCloud API.\"\"\"\n        error_message = None\n        max_attempts = 3\n        timeout = 1000\n\n        for attempt in range(max_attempts):\n            try:\n                url_args = data.pop(\"url_args\", None)\n\n                if url_args:\n                    formatted_url = self._sanitize_url(url, url_args)\n                else:\n                    formatted_url = url\n\n                request_function = getattr(requests, type)\n\n                response = request_function(\n                    formatted_url, headers=self.headers, json=data, timeout=timeout\n                )\n                break\n            except ConnectionError:\n                if attempt < max_attempts - 1:\n                    continue\n                else:\n                    error_message = (\n                        f\"Connection error occurred {endpoint_error_message}\"\n                    )\n            except HTTPError as http_err:\n                error_message = (\n                    f\"HTTP error occurred {endpoint_error_message}{http_err}\"\n                )\n            except Timeout:\n                error_message = f\"Timeout occurred {endpoint_error_message}\"\n            except RequestException as err:\n                error_message = f\"Other error occurred {endpoint_error_message}{err}\"\n            except Exception as e:\n                error_message = (\n                    f\"An unexpected error occurred {endpoint_error_message}{e}\"\n                )\n\n        if error_message:\n            print(error_message)\n            send_email(\n                \"There was an error executing a request on SellerCloud API : \",\n                error_message,\n            )\n            return None\n        elif response.status_code != 200:\n            print(f\"Error: Received status code {response.status_code}\")\n            return response\n        else:\n            print(success_message)\n            return response\n\n    def _sanitize_url(self, url, url_args):\n        \"\"\"Constructs a URL for a  API request.\"\"\"\n        sanitized_url_args = {k: quote(str(v)) for k, v in url_args.items()}\n        return url.format(**sanitized_url_args)\n"
      },
      {
        "filename": "spinner.py",
        "code": "import threading\nimport time\n\n\nclass Spinner:\n    \"\"\"A class to create a console-based spinner for indicating ongoing actions.\"\"\"\n\n    def __init__(self, spinner_chars=\"|/-\\\\\", speed=0.1):\n        \"\"\"Initialize the spinner with custom characters and speed.\"\"\"\n        self._stop_spinner = threading.Event()\n        self._spinner_chars = spinner_chars\n        self._speed = speed\n        self.bg_thread = None\n\n    def _spinner_task(self, action):\n        \"\"\"Private method to handle the spinner animation.\"\"\"\n        while not self._stop_spinner.is_set():\n            for char in self._spinner_chars:\n                print(f\"\\r{action}... {char}   \", end=\"\", flush=True)\n                time.sleep(self._speed)\n        print(f\"\\r{action}... Done!   \", end=\"\", flush=True)\n\n    def start(self, action):\n        \"\"\"Start the spinner for a given action.\"\"\"\n        if self._stop_spinner.is_set():\n            self._stop_spinner.clear()\n        self.bg_thread = threading.Thread(\n            target=self._spinner_task,\n            args=(action,),\n        )\n        self.bg_thread.start()\n\n    def stop(self):\n        \"\"\"Stop the spinner.\"\"\"\n        self._stop_spinner.set()\n        self.bg_thread.join()\n        self.bg_thread = None\n        self._stop_spinner.clear()\n"
      }
    ],
    "repoLink": "https://github.com/aborroto1984/pdf_invoice_report",
    "technologies": [
      { name: "Python", icon: `${process.env.PUBLIC_URL}/icons/python.png` },
      { name: "API", icon: `${process.env.PUBLIC_URL}/icons/API.png` },
      { name: "Azure", icon: `${process.env.PUBLIC_URL}/icons/azure.png` },
      { name: "SQL", icon: `${process.env.PUBLIC_URL}/icons/sql.png` },
      { name: "Git", icon: `${process.env.PUBLIC_URL}/icons/git.png` },
      { name: "SellerCloud", icon: `${process.env.PUBLIC_URL}/icons/sellercloud.png` },
      { name: "ReportLab", icon: `${process.env.PUBLIC_URL}/icons/reportlab.webp` },
    ]
  },
  {
    "title": "QB Journal Entry Creator",
    "description": "This project automates the process of retrieving sales data from SellerCloud, calculating cost of goods sold, and creating journal entries in QuickBooks.",
    "files": [
      {
        "filename": "README.md",
        "code": "# QuickBooks Journal Entry Automation System\n\nThis project automates the process of retrieving sales data from SellerCloud, calculating cost of goods sold, and creating journal entries in QuickBooks.\n\n## Features\n- Fetches sales data from SellerCloud for multiple channels.\n- Calculates cost of goods sold (COGS).\n- Creates individual and combined journal entries in QuickBooks.\n- Attaches reports to journal entries in QuickBooks.\n- Sends email notifications for errors and updates.\n\n## Project Structure\n```\nproject_root/\n├── config.py              # Configuration file for database, API, and email credentials\n├── decimal_rounding.py    # Rounds decimal values for financial accuracy\n├── email_helper.py        # Sends email notifications\n├── helpers.py             # Utility functions for data processing\n├── main.py                # Main script orchestrating journal entry creation\n├── qb_api.py              # Handles QuickBooks API interactions\n├── quick_books_db.py      # Manages QuickBooks database operations\n├── seller_cloud_api.py    # Interfaces with SellerCloud API\n```\n\n## Installation & Setup\n\n### 1. Clone the Repository\n```bash\ngit clone https://github.com/your-repo/qb-journal-automation.git\ncd qb-journal-automation\n```\n\n### 2. Install Dependencies\nEnsure you have Python 3 installed, then install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n### 3. Configure the System\nModify `config.py` with your database, QuickBooks, and SellerCloud credentials.\n\nExample database configuration:\n```python\ndb_config = {\n    \"ExampleDb\": {\n        \"server\": \"your.database.windows.net\",\n        \"database\": \"YourDB\",\n        \"username\": \"your_user\",\n        \"password\": \"your_password\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n    },\n}\n```\nExample email configuration:\n```python\nSENDER_EMAIL = \"your_email@example.com\"\nSENDER_PASSWORD = \"your_email_password\"\n```\n\n## Usage\nRun the main script to start the journal entry process:\n```bash\npython main.py\n```\n\n## How It Works\n1. Fetches sales data from SellerCloud.\n2. Calculates cost of goods sold for each channel.\n3. Creates individual journal entries in QuickBooks.\n4. Optionally creates a combined journal entry.\n5. Attaches generated reports to QuickBooks entries.\n6. Sends email notifications upon success or failure.\n\n## Tech Stack\n- Python 3\n- Azure SQL Database (`pyodbc`)\n- SellerCloud API Integration\n- QuickBooks API Integration\n- Email Notifications (`smtplib`)\n- Decimal rounding for financial accuracy\n\n## Troubleshooting\n- If you encounter database connection issues, ensure `ODBC Driver 17` is installed.\n- If emails fail to send, ensure your SMTP settings allow external authentication.\n- Verify SellerCloud and QuickBooks credentials if API requests fail.\n"
      },
      {
        "filename": "main.py",
        "code": "from quick_books_db import QuickBooksDb\nfrom seller_cloud_api import SellerCloudAPI\nfrom qb_api import QbAPI\nfrom email_helper import send_email\nfrom datetime import datetime, timedelta\nimport traceback\nfrom helpers import Helpers\nfrom decimal_rounding import round_to_decimal\n\n\ndef main():\n    try:\n        config = {\n            \"run_DF\": True,\n            \"run_WH\": True,\n            \"run_VN\": True,\n            \"run_combined\": False,\n            \"run_individual\": True,\n        }\n\n        class Frequency:\n            def __init__(self):\n                self.daily = \"daily\"\n                self.weekly = \"weekly\"\n                self.monthly = \"monthly\"\n\n        h = Helpers()\n        f = Frequency()\n        sc_api = SellerCloudAPI()\n\n        today = datetime.now() - timedelta(days=1)\n\n        # from_date, to_date = h.create_date_range(today, f.monthly)\n        from_date, to_date = h.create_date_range(today, f.daily)\n        print(f\"Date range. From date: {from_date}, To date: {to_date}\")\n\n        # Getting orders------------------------------------------------------------------------\n        all_orders = {}\n\n        # DF\n        if config[\"run_DF\"]:\n            df_orders = h.get_sc_orders(from_date, to_date, 66, sc_api)\n            if df_orders:\n                all_orders[\"DF\"] = df_orders\n\n        # Dropship\n        if config[\"run_WH\"]:\n            dropship_orders = h.get_sc_orders(from_date, to_date, 21, sc_api)\n            if dropship_orders:\n                all_orders[\"WH\"] = dropship_orders\n\n        # Amazon Vendor\n        if config[\"run_VN\"]:\n            amz_ven_orders = h.get_sc_orders(\n                from_date, to_date, 0, sc_api, channel_name=\"VN\"\n            )\n            if amz_ven_orders:\n                all_orders[\"VN\"] = amz_ven_orders\n\n        if all_orders:\n\n            # Extracting cost of goods sold from SellerCloud------------------------------------------------------------------------\n            qb_db = QuickBooksDb()\n            current_refresh_token = qb_db.get_refresh_token()\n            qb_api = QbAPI(current_refresh_token)\n\n            if qb_api.client.refresh_token != current_refresh_token:\n                qb_db.update_refresh_token(qb_api.client.refresh_token)\n\n            channel_amounts_and_report = {}\n\n            for channel, orders in all_orders.items():\n                print(f\"Processing {channel} - {len(orders)} orders...\")\n\n                # Extracting channel amounts and creating journal report rows\n                channel_amount, report_rows = h.get_channel_cost_amounts(\n                    orders, channel\n                )\n\n                channel_amount = round_to_decimal(channel_amount)\n                report_path = h.create_journal_report(report_rows, channel)\n\n                channel_amounts_and_report[channel] = {\n                    \"channel_amount\": channel_amount,\n                    \"report_path\": report_path,\n                }\n                print(\n                    f\"Channel: {channel}, Order: {len(orders)} Amount: {channel_amount}\"\n                )\n\n            # Creating individual journal entries------------------------------------------------------------------------\n            if config[\"run_individual\"]:\n                journals_created = []\n                if not channel_amounts_and_report:\n                    send_email(\n                        \"No journal created\",\n                        \"There was no sales data to create journal with.\",\n                    )\n\n                for channel, data in channel_amounts_and_report.items():\n                    amount = data[\"channel_amount\"]\n                    report_path = data[\"report_path\"]\n\n                    if amount > 0:\n                        journal_entry_number = qb_api.create_journal_entry(\n                            amount, channel, to_date\n                        )\n                        if journal_entry_number:\n                            journal_entry_id = qb_api.get_journal_entry_id(\n                                journal_entry_number\n                            )\n                            if journal_entry_id:\n                                print(\n                                    f\"Individual journal entry {journal_entry_number} created for {channel}\"\n                                )\n                                if qb_api.attach_file_to_journal_entry(\n                                    report_path, journal_entry_id\n                                ):\n                                    print(\n                                        f\"File attached to journal entry for {channel}\"\n                                    )\n                                    journals_created.append(journal_entry_number)\n\n                print(\"Individual journal entries created\")\n                entries_str = \", \".join(journals_created)\n                send_email(\n                    \"Journal Entries Created\",\n                    f\"Journal entries created: {entries_str}\",\n                )\n\n            # Creating combined journal entry------------------------------------------------------------------------\n            if config[\"run_combined\"]:\n                journal_entry_number = qb_api.create_combined_journal_entry(\n                    channel_amounts_and_report, to_date\n                )\n                print(f\"Combined journal created, entry number: {journal_entry_number}\")\n                journal_entry_id = qb_api.get_journal_entry_id(journal_entry_number)\n                for file_path in [\n                    amount[\"report_path\"]\n                    for amount in channel_amounts_and_report.values()\n                ]:\n                    if qb_api.attach_file_to_journal_entry(file_path, journal_entry_id):\n                        print(\n                            f\"File {file_path} \\nattached to journal entry {journal_entry_number}\"\n                        )\n\n                print(\"Combined journal entry created\")\n\n    except Exception as e:\n        print(e)\n        send_email(\"Unexpected Error\", traceback.format_exc())\n        raise e\n\n\nif __name__ == \"__main__\":\n    main()\n"
      },
      {
        "filename": "config.py",
        "code": "sellercloud_credentials = {\n    \"Username\": \"username\",\n    \"Password\": \"password\",\n}\n\nsellercloud_base_url = \"https://company.api.sellercloud.us/rest/api/\"\n\nsellercloud_endpoints = {\n    \"GET_TOKEN\": {\n        \"type\": \"post\",\n        \"url\": sellercloud_base_url + \"token\",\n        \"endpoint_error_message\": \"while getting SellerCoud API access token: \",\n        \"success_message\": \"Got SellerCloud API access token successfully!\",\n    },\n    \"GET_SELLERCLOUD_ORDERS\": {\n        \"type\": \"get\",\n        \"url\": sellercloud_base_url\n        + \"Orders?model.companyID=163&model.orderStatus=3&model.shipFromDate={from}&model.shipToDate={to}&model.channel={channel}&model.pageNumber={page}&model.pageSize=50\",\n        \"endpoint_error_message\": \"while getting orders from SellerCloud: \",\n        \"success_message\": \"Got all orders from SellerCloud successfully!\",\n    },\n    \"GET_AMZ_VEN_ORDERS\": {\n        \"type\": \"get\",\n        \"url\": sellercloud_base_url\n        + \"Orders?model.companyID=163&model.orderStatus=3&model.shipFromDate={from}&model.shipToDate={to}&model.channel={channel}&model.userID=75437&model.pageNumber={page}&model.pageSize=50\",\n        \"endpoint_error_message\": \"while getting orders from SellerCloud: \",\n        \"success_message\": \"Got all orders from SellerCloud successfully!\",\n    },\n}\n\ndb_config = {\n    \"ExampleDb\": {\n        \"server\": \"example.database.windows.net\",\n        \"database\": \"ExampleDb\",\n        \"username\": \"example\",\n        \"password\": \"example\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n        \"port\": 1433,  # Default port for SQL Server\n    },\n    \"QbExampleDb\": {\n        \"server\": \"example.database.windows.net\",\n        \"database\": \"QbExampleDb\",\n        \"username\": \"example\",\n        \"password\": \"example\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n        \"port\": 1433,  # Default port for SQL Server\n    },\n}\n\n\ndef create_connection_string(server_config):\n    return (\n        f\"DRIVER={server_config['driver']};\"\n        f\"SERVER={server_config['server']};\"\n        f\"PORT={server_config[\"port\"]};DATABASE={server_config['database']};\"\n        f\"UID={server_config['username']};\"\n        f\"PWD={server_config['password']}\"\n    )\n\n\nSENDER_EMAIL = \"sender_email@domain.com\"\nSENDER_PASSWORD = \"sender_password\"\nRECIPIENT_EMAILS = [\n    \"recipient_email_1@domain.com\",\n    \"recipient_email_2@domain.com\",\n]  # List of emails to send the report\n\n\nclient_data = {\n    \"client_id\": \"example_client_id\",\n    \"client_secret\": \"example_client_secret\",\n    \"redirect_uri\": \"example_redirect_uri\",\n    \"environment\": \"sandbox\",\n    \"realm_id\": \"example_realm_id\",\n    \"access_token\": \"example_access_token\",\n}\n\nref_id_map = {\n    \"DF\": {\n        \"class_ref_id\": \"fake_class_ref_id\",\n    },\n    \"WH\": {\n        \"class_ref_id\": \"fake_class_ref_id\",\n    },\n    \"VN\": {\n        \"class_ref_id\": \"fake_class_ref_id\",\n    },\n}\n"
      },
      {
        "filename": "decimal_rounding.py",
        "code": "from decimal import Decimal, ROUND_HALF_UP\n\n\ndef round_to_decimal(number):\n    \"\"\"Round a number to a given precision.\"\"\"\n    decimal_number = Decimal(str(number))\n    rounded_number = decimal_number.quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)\n\n    return float(rounded_number)\n"
      },
      {
        "filename": "email_helper.py",
        "code": "# email_helper.py\nimport smtplib\nfrom email.message import EmailMessage\nfrom config import SENDER_EMAIL, SENDER_PASSWORD, RECIPIENT_EMAILS\nimport os\nimport getpass\nimport socket\n\n\ndef send_email(subject, body):\n    current_dir = os.getcwd()\n    folder_name = os.path.basename(current_dir)\n    computer_name = socket.gethostname()\n    user_name = getpass.getuser()\n    new_line = \"\\n\"\n    body_with_new_line = (\n        f\"{body}{new_line}{folder_name} on {computer_name} ({user_name})\"\n    )\n    msg = EmailMessage()\n    msg.set_content(body_with_new_line)\n    msg[\"Subject\"] = f\"{subject} : {folder_name}\"\n    msg[\"From\"] = SENDER_EMAIL\n    msg[\"To\"] = \", \".join(RECIPIENT_EMAILS)\n\n    try:\n        with smtplib.SMTP_SSL(\"smtp.gmail.com\", 465) as server:\n            server.login(SENDER_EMAIL, SENDER_PASSWORD)\n            server.send_message(msg)\n        print(\"Email sent successfully.\")\n    except Exception as e:\n        print(f\"Error sending email: {e}\")\n"
      },
      {
        "filename": "helpers.py",
        "code": "from seller_cloud_api import SellerCloudAPI\nfrom email_helper import send_email\nfrom datetime import datetime\nimport pandas as pd\nfrom qb_api import QbAPI\nimport os\nimport pathlib\nfrom datetime import timedelta\n\n\nclass Frequency:\n    def __init__(self):\n        self.daily = \"daily\"\n        self.weekly = \"weekly\"\n        self.monthly = \"monthly\"\n\n\nclass Helpers:\n    def get_channel_amounts(self, invoices, channel):\n        \"\"\"Gets the total amount of the invoices.\"\"\"\n        rows = []\n        total_amount = 0\n        for sc_id, invoice in invoices.items():\n            for line in invoice.Line:\n                if line.DetailType == \"SalesItemLineDetail\":\n                    total_amount += line.Amount\n                    if channel == \"VN\":\n                        sku = line.Description.split(\",\")[0]\n                    else:\n                        sku = line.Description\n\n                    # This prevents adding rows for taxes and shipping in the report.\n                    if line.Description == \"Taxes\" or line.Description == \"Shipping\":\n                        continue\n\n                    rows.append(\n                        {\n                            \"sc_order_id\": sc_id,\n                            \"purchase_order_number\": invoice.DocNumber,\n                            \"sku\": sku,\n                            \"item_cost\": line.SalesItemLineDetail.UnitPrice,\n                            \"qty\": line.SalesItemLineDetail.Qty,\n                            \"total_cost\": line.SalesItemLineDetail.UnitPrice\n                            * line.SalesItemLineDetail.Qty,\n                        }\n                    )\n        return total_amount, rows\n\n    def format_po_date(self, date):\n        try:\n            dt_obj = datetime.strptime(date, \"%Y-%m-%dT%H:%M:%S.%f\")\n        except ValueError:\n            # Fallback to parsing without microseconds\n            dt_obj = datetime.strptime(date, \"%Y-%m-%dT%H:%M:%S\")\n\n        return dt_obj.strftime(\"%Y-%m-%d %I:%M %p\").lower()\n\n    def get_channel_cost_amounts(self, orders, channel):\n        \"\"\"Gets the total amount of the invoices.\"\"\"\n        rows = []\n        total_amount = 0\n        for order in orders:\n            for item in order[\"Items\"]:\n                item_cost = item[\"AverageCost\"]\n                rows.append(\n                    {\n                        \"po_date\": self.format_po_date(order[\"ShipDate\"]),\n                        \"sc_order_id\": order[\"ID\"],\n                        \"purchase_order_number\": order[\"OrderSourceOrderID\"],\n                        \"sku\": item[\"ProductIDOriginal\"],\n                        \"item_cost\": item_cost,\n                        \"qty\": item[\"Qty\"],\n                        \"total_cost\": item_cost * item[\"Qty\"],\n                    }\n                )\n                total_amount += item_cost * item[\"Qty\"]\n        return total_amount, rows\n\n    def create_date_range(self, date, frequency: Frequency):\n        \"\"\"Finds the first and last date according to the frequency.\"\"\"\n        if frequency == \"daily\":\n            first_day = date.strftime(\"%m/%d/%Y 00:00:00\")\n            last_day = date.strftime(\"%m/%d/%Y 23:59:59\")\n        elif frequency == \"weekly\":\n            first_day = date - timedelta(days=date.weekday())\n            last_day = date + timedelta(days=6 - date.weekday())\n            first_day, last_day = self.split_week_if_ends_in_month(first_day, last_day)\n\n        elif frequency == \"monthly\":\n            first_day = date.replace(day=1).strftime(\"%m/%d/%Y 00:00:00\")\n            last_day = (\n                date.replace(month=date.month + 1, day=1) - timedelta(days=1)\n            ).strftime(\"%m/%d/%Y 23:59:59\")\n\n        return first_day, last_day\n\n    def split_week_if_ends_in_month(self, first_day, last_day):\n        \"\"\"Splits the week if it ends in a month. Returns week start and end dates.\"\"\"\n\n        date_format = \"%m/%d/%Y %H:%M:%S\"\n\n        # Calculate the last day of the start date's month\n        next_month = first_day.replace(day=28) + timedelta(\n            days=4\n        )  # This will never fail\n        end_of_month = next_month - timedelta(days=next_month.day)\n\n        # Adjust the end date if it exceeds the end of the month\n        if last_day > end_of_month:\n            last_day = end_of_month.replace(hour=23, minute=59, second=59)\n            first_day = first_day.replace(hour=0, minute=0, second=0)\n        else:\n            last_day = last_day.replace(hour=23, minute=59, second=59)\n            first_day = first_day.replace(hour=0, minute=0, second=0)\n\n        # Return the new date range in the desired string format\n        return first_day.strftime(date_format), last_day.strftime(date_format)\n\n    def split_dict(self, input_dict, chunk_size):\n        \"\"\"\n        Splits a dictionary into a list of dictionaries of a designated size.\n\n        :param input_dict: Dictionary to be split.\n        :param chunk_size: Size of each chunk.\n        :return: List of dictionaries.\n        \"\"\"\n        # Convert the dictionary items to a list\n        items = list(input_dict.items())\n\n        # Use list comprehension to split the list into chunks\n        chunked_dicts = [\n            dict(items[i : i + chunk_size]) for i in range(0, len(items), chunk_size)\n        ]\n\n        return chunked_dicts\n\n    def get_sc_orders(\n        self, from_date, to_date, channel, sc_api: SellerCloudAPI, channel_name=None\n    ):\n        \"\"\"Gets orders from SellerCloud.\"\"\"\n        try:\n            orders = []\n            page = 1\n            while True:\n                if channel_name == \"VN\":\n                    excecute = \"GET_AMZ_VEN_ORDERS\"\n\n                else:\n                    excecute = \"GET_SELLERCLOUD_ORDERS\"\n\n                response = sc_api.execute(\n                    {\n                        \"url_args\": {\n                            \"from\": from_date,\n                            \"to\": to_date,\n                            \"channel\": channel,\n                            \"page\": page,\n                        }\n                    },\n                    excecute,\n                )\n\n                if response.status_code == 200:\n                    if response.json()[\"Items\"]:\n                        orders.extend(response.json()[\"Items\"])\n                        page += 1\n                    else:\n                        break\n                else:\n                    print(f\"Error: Received status code {response.status_code}\")\n                    raise Exception(\n                        f\"Error: Received while getting orders from SellerCloud code {response.status_code}\"\n                    )\n\n            return orders\n        except Exception as e:\n            print(f\"There was an error getting the orders from SellerCloud: {e}\")\n            return None\n\n    def failure_reporting(self, where, po):\n        send_email(f\"Error {where}\", f\"Error creating order for PO: {po}.\")\n\n    def create_journal_report(self, rows, channel):\n        channel_name_map = {\n            \"VN\": \"amazon_vendor\",\n            \"DF\": \"direct_fulfillment\",\n            \"WH\": \"dropship\",\n        }\n\n        df = pd.DataFrame(rows)\n        directory = self._create_local_dir()\n        file_name = os.path.join(directory, f\"{channel_name_map[channel]}_orders.xlsx\")\n        df.to_excel(file_name, index=False)\n\n        return file_name\n\n    def _create_local_dir(self):\n        dir_name = f\"{datetime.now().strftime('%b%d,%Y').upper()}\"\n        local_dir = pathlib.Path(f\"tmp/{dir_name}\")\n        local_dir.mkdir(parents=True, exist_ok=True)\n        return local_dir\n"
      },
      {
        "filename": "qb_api.py",
        "code": "from config import client_data, ref_id_map\nfrom intuitlib.client import AuthClient\nfrom quickbooks import QuickBooks\nfrom quickbooks.objects import (\n    Class,\n    Account,\n    Invoice,\n    JournalEntry,\n    JournalEntryLine,\n    JournalEntryLineDetail,\n    Attachable,\n    AttachableRef,\n    Customer,\n)\nfrom datetime import datetime\nimport os\n\n\nclass QbAPI:\n    def __init__(self, current_refresh_token):\n        self.auth_client = AuthClient(\n            client_id=client_data[\"client_id\"],\n            client_secret=client_data[\"client_secret\"],\n            environment=client_data[\"environment\"],\n            redirect_uri=client_data[\"redirect_uri\"],\n        )\n        self.client = QuickBooks(\n            auth_client=self.auth_client,\n            refresh_token=current_refresh_token,\n            company_id=client_data[\"realm_id\"],\n        )\n\n    def get_journal_entry_id(self, doc_name):\n        \"\"\"\n        Gets the ID of a QuickBooks journal entry by its document number (DocNumber).\n        \"\"\"\n        try:\n            if JournalEntry.filter(DocNumber=doc_name, qb=self.client):\n                return JournalEntry.filter(DocNumber=doc_name, qb=self.client)[0].Id\n            else:\n                return False\n        except Exception as e:\n            print(\n                f\"There was an error checking if PO: {doc_name} was already invoiced: {e}\"\n            )\n            return False\n\n    def create_journal_entry(self, amount, channel, to_date):\n        \"\"\"\n        Creates a journal entry in QuickBooks for a specific channel.\n        \"\"\"\n        try:\n            # Creating credit line\n            credit_line_detail = JournalEntryLineDetail()\n            credit_line_detail.AccountRef = Account.get(29, qb=self.client).to_ref()\n            credit_line_detail.PostingType = \"Credit\"\n            credit_line_detail.TaxApplicableOn = \"Sales\"\n\n            credit_line = JournalEntryLine()\n            credit_line.Amount = amount\n            credit_line.JournalEntryLineDetail = credit_line_detail\n\n            # Creating cost line\n            cost_line_detail = JournalEntryLineDetail()\n            cost_line_detail.AccountRef = Account.get(46, qb=self.client).to_ref()\n            cost_line_detail.ClassRef = Class.get(\n                ref_id_map[channel][\"class_ref_id\"], qb=self.client\n            ).to_ref()\n            cost_line_detail.PostingType = \"Debit\"\n            cost_line_detail.TaxApplicableOn = \"Sales\"\n\n            cost_line = JournalEntryLine()\n            cost_line.Amount = amount\n            cost_line.JournalEntryLineDetail = cost_line_detail\n\n            # Creating journal entry\n            date = to_date[:10]\n            date = datetime.strptime(date, \"%m/%d/%Y\")\n            date_for_doc_name = date.strftime(\"%m%d%Y\")\n            journal_entry = JournalEntry()\n            journal_entry.DocNumber = f\"{channel}_COG_{date_for_doc_name}_SC\"\n            journal_entry.TxnDate = date.strftime(\"%Y-%m-%d\")\n            journal_entry.Line = [credit_line, cost_line]\n\n            journal_entry.save(qb=self.client)\n            return journal_entry.DocNumber\n\n        except Exception as e:\n            print(f\"Error while creating journal entry: {e}\")\n\n    def create_combined_journal_entry(self, channel_amounts_and_report, to_date):\n        \"\"\"\n        Creates a combined journal entry in QuickBooks for all channels.\n        \"\"\"\n        try:\n            total_amount = sum(\n                amount[\"channel_amount\"]\n                for amount in channel_amounts_and_report.values()\n            )\n\n            lines = []\n\n            # Creating credit line\n            credit_line_detail = JournalEntryLineDetail()\n            credit_line_detail.AccountRef = Account.get(29, qb=self.client).to_ref()\n            credit_line_detail.PostingType = \"Credit\"\n            credit_line_detail.TaxApplicableOn = \"Sales\"\n\n            credit_line = JournalEntryLine()\n            credit_line.Amount = total_amount\n            credit_line.JournalEntryLineDetail = credit_line_detail\n            lines.append(credit_line)\n\n            for channel, amount in channel_amounts_and_report.items():\n                # Creating cost line\n                cost_line_detail = JournalEntryLineDetail()\n                cost_line_detail.AccountRef = Account.get(46, qb=self.client).to_ref()\n                cost_line_detail.ClassRef = Class.get(\n                    ref_id_map[channel][\"class_ref_id\"], qb=self.client\n                ).to_ref()\n                cost_line_detail.PostingType = \"Debit\"\n                cost_line_detail.TaxApplicableOn = \"Sales\"\n\n                cost_line = JournalEntryLine()\n                cost_line.Amount = amount[\"channel_amount\"]\n                cost_line.JournalEntryLineDetail = cost_line_detail\n                lines.append(cost_line)\n\n            # Creating journal entry\n            date = datetime.strptime(to_date, \"%m/%d/%Y\")\n            date_for_doc_name = date.strftime(\"%b%d\").upper()\n\n            journal_entry = JournalEntry()\n            journal_entry.DocNumber = f\"COG_{date_for_doc_name}_SC\"\n            # journal_entry.DocNumber = \"test_journal\"\n            journal_entry.TxnDate = date.strftime(\"%Y-%m-%d\")\n            journal_entry.Line = lines\n\n            journal_entry.save(qb=self.client)\n            return journal_entry.DocNumber\n\n        except Exception as e:\n            print(f\"Error while creating journal entry: {e}\")\n\n    def attach_file_to_journal_entry(self, file_path, journal_entry_id):\n        \"\"\"\n        Attaches a file to a QuickBooks journal entry.\n        \"\"\"\n        try:\n            file_name = os.path.basename(file_path)\n\n            attachment = Attachable()\n\n            attachable_ref = AttachableRef()\n            attachable_ref.EntityRef = {\n                \"type\": \"JournalEntry\",  # The type of the entity being referenced\n                \"value\": journal_entry_id,  # The ID of the journal entry\n            }\n            attachment.AttachableRef.append(attachable_ref)\n\n            attachment.FileName = file_name\n            attachment._FilePath = file_path\n            attachment.ContentType = (\n                \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n            )\n            attachment.save(qb=self.client)\n\n            return True\n\n        except Exception as e:\n            print(f\"Error while attaching file to journal entry: {e}\")\n            return False\n\n    def delete_journal_entry(self, txn_id):\n        \"\"\"\n        Deletes a QuickBooks journal entry by its transaction ID (TxnId).\n\n        Args:\n            quickbooks_client (QuickBooks): The authenticated QuickBooks client.\n            txn_id (str): The transaction ID (TxnId) of the journal entry to delete.\n\n        Returns:\n            bool: True if the entry was successfully deleted, False otherwise.\n        \"\"\"\n        try:\n            # Retrieve the journal entry by TxnId\n            journal_entry = JournalEntry.filter(DocNumber=txn_id, qb=self.client)[0]\n\n            # Delete the journal entry\n            journal_entry.delete(qb=self.client)\n\n            print(f\"Journal entry with TxnId {txn_id} has been deleted.\")\n            return True\n        except Exception as e:\n            print(f\"Failed to delete journal entry with TxnId {txn_id}: {e}\")\n            return False\n"
      },
      {
        "filename": "quick_books_db.py",
        "code": "import pyodbc\nfrom config import create_connection_string, db_config\n\n\nclass QuickBooksDb:\n    def __init__(self):\n        self.conn = pyodbc.connect(create_connection_string(db_config[\"QbExampleDb\"]))\n        self.cursor = self.conn.cursor()\n\n    def get_refresh_token(self):\n        self.cursor.execute(\"SELECT TOP 1 (refresh_token) FROM keys ORDER BY ID DESC\")\n        return self.cursor.fetchone()[0]\n\n    def update_refresh_token(self, refresh_token):\n        conn = pyodbc.connect(create_connection_string(db_config[\"QbExampleDb\"]))\n        cursor = conn.cursor()\n        cursor.execute(\"INSERT INTO keys (refresh_token) VALUES (?)\", refresh_token)\n        conn.commit()\n        return True\n"
      },
      {
        "filename": "seller_cloud_api.py",
        "code": "import requests\nfrom requests.exceptions import HTTPError, Timeout, RequestException\nfrom email_helper import send_email\nfrom urllib.parse import quote\nfrom config import sellercloud_credentials, sellercloud_endpoints\n\n\nclass SellerCloudAPI:\n    \"\"\"\n    Class to handle requests to the Seller Cloud order managing API.\n    It takes a dictionary with the credentials and a dictionary with the endpoints both from config.py.\n    The endpoints dictionary should have the following structure:\n    endpoints = {\n        \"EXAMPLE\": {\n        \"type\": \"post\", \"get\" or \"delete\",\n        \"url\": the url of the endpoint with the placeholders for the url_args in the format {url_arg},\n        \"endpoint_error_message\": the error message fragment to be displayed if the request fails in the format \"while (the action it was performing): \",\n        \"success_message\": the success message to be displayed if the request is successful in the format \"(API name) (action it was performing) successfully!\",\n    },\n    \"\"\"\n\n    def __init__(self):\n        self.data = sellercloud_credentials\n        self.endpoints = sellercloud_endpoints\n        response = self.execute(self.data, \"GET_TOKEN\")\n        self.token = response.json()[\"access_token\"]\n        self.headers = {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"Authorization\": f\"Bearer {self.token}\",\n        }\n\n    def execute(self, data, action):\n        \"\"\"Executes a request to the SellerCloud API.\n        Valid actions are: CREATE_ORDER, ADD_ITEM, GET_PRODUCT, GET_TOTAL, UPDATE_TAX, DELETE_ORDER.\n        The data parameter should be a dictionary with the data to be sent to the API and the url_args to be used in the url in the format:\n        data = {\n            \"url_args\": {\"url_arg1\": \"value1\", \"url_arg2\": \"value2\"...},\n            \"data_key\": \"data_value\"\n            \"data_key2\": \"data_value2\"...,\n        }\n        The url_args are the values that will be used to replace the placeholders in the url like this: {url_arg1} -> value1\n        url_exammple = \"https://url_example.com/{url_arg1}/{url_arg2}\"\n        \"\"\"\n        config = self.endpoints.get(action)\n        if not config:\n            raise ValueError(\"Invalid API action\")\n\n        if action == \"GET_TOKEN\":\n            self.headers = None\n            return self.perform_request(self.data, **config)\n\n        return self.perform_request(data, **config)\n\n    def perform_request(\n        self,\n        data,\n        type,\n        url,\n        endpoint_error_message,\n        success_message,\n    ):\n        \"\"\"Performs a request to the SellerCloud API.\"\"\"\n        error_message = None\n        max_attempts = 3\n        timeout = 1000\n\n        for attempt in range(max_attempts):\n            try:\n                data_copy = data.copy()\n                url_args = data_copy.pop(\"url_args\", None)\n\n                if url_args:\n                    formatted_url = self._sanitize_url(url, url_args)\n                else:\n                    formatted_url = url\n\n                request_function = getattr(requests, type)\n\n                response = request_function(\n                    formatted_url, headers=self.headers, json=data, timeout=timeout\n                )\n                break\n            except ConnectionError:\n                if attempt < max_attempts - 1:\n                    continue\n                else:\n                    error_message = (\n                        f\"Connection error occurred {endpoint_error_message}\"\n                    )\n            except HTTPError as http_err:\n                error_message = (\n                    f\"HTTP error occurred {endpoint_error_message}{http_err}\"\n                )\n            except Timeout:\n                error_message = f\"Timeout occurred {endpoint_error_message}\"\n            except RequestException as err:\n                error_message = f\"Other error occurred {endpoint_error_message}{err}\"\n            except Exception as e:\n                error_message = (\n                    f\"An unexpected error occurred {endpoint_error_message}{e}\"\n                )\n\n        if error_message:\n            print(error_message)\n            send_email(\n                \"There was an error executing a request on SellerCloud API : \",\n                error_message,\n            )\n            return None\n        elif response.status_code != 200:\n            print(f\"Error: Received status code {response.status_code}\")\n            return response\n        else:\n            print(success_message)\n            return response\n\n    def _sanitize_url(self, url, url_args):\n        \"\"\"Constructs a URL for a  API request.\"\"\"\n        sanitized_url_args = {k: quote(str(v)) for k, v in url_args.items()}\n        return url.format(**sanitized_url_args)\n"
      }
    ],
    "repoLink": "https://github.com/aborroto1984/qb_journal_entry_creator",
    "technologies": [
      { name: "Python", icon: `${process.env.PUBLIC_URL}/icons/python.png` },
      { name: "API", icon: `${process.env.PUBLIC_URL}/icons/API.png` },
      { name: "Azure", icon: `${process.env.PUBLIC_URL}/icons/azure.png` },
      { name: "SQL", icon: `${process.env.PUBLIC_URL}/icons/sql.png` },
      { name: "Git", icon: `${process.env.PUBLIC_URL}/icons/git.png` },
      { name: "SellerCloud", icon: `${process.env.PUBLIC_URL}/icons/sellercloud.png` },
      { name: "QuickBooks", icon: `${process.env.PUBLIC_URL}/icons/quickbooks.webp` },
    ]
  },
  {
    "title": "Returns App",
    "description": "This project provides a PyQt-based application to manage returns check-ins, update tracking information, and handle pallet form generation.",
    "files": [
      {
        "filename": "README.md",
        "code": "# Returns Check-In System\n\nThis project provides a PyQt-based application to manage returns check-ins, update tracking information, and handle pallet form generation.\n\n## Features\n- Fetches return details from the database using tracking numbers.\n- Updates return status and notes.\n- Supports pallet returns with multiple SKUs.\n- Generates printable pallet checklist PDFs.\n- Provides a user-friendly PyQt interface.\n\n## Project Structure\n```\nproject_root/\n├── config.py              # Configuration file for database, API, and email credentials\n├── email_helper.py        # Sends email notifications\n├── example_db.py          # Manages database interactions for return processing\n├── label_updater.py       # Updates labels asynchronously using PyQt signals\n├── main.py                # Main script launching the PyQt application\n├── pallet_form.py         # Generates printable PDF checklists\n├── ui.py                  # Defines the graphical user interface with PyQt\n```\n\n## Installation & Setup\n\n### 1. Clone the Repository\n```bash\ngit clone https://github.com/your-repo/returns-checkin.git\ncd returns-checkin\n```\n\n### 2. Install Dependencies\nEnsure you have Python 3 installed, then install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n### 3. Configure the System\nModify `config.py` with your database credentials.\n\nExample database configuration:\n```python\ndb_config = {\n    \"ExampleDb\": {\n        \"server\": \"your.database.windows.net\",\n        \"database\": \"YourDB\",\n        \"username\": \"your_user\",\n        \"password\": \"your_password\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n    },\n}\n```\n\nExample email configuration:\n```python\nSENDER_EMAIL = \"your_email@example.com\"\nSENDER_PASSWORD = \"your_email_password\"\n```\n\n## Usage\nRun the main script to start the application:\n```bash\npython main.py\n```\n\n## How It Works\n1. User enters a tracking number.\n2. System retrieves return details from the database.\n3. User selects a return status and updates notes.\n4. If part of a pallet, a checklist PDF can be printed.\n5. Updated details are saved back to the database.\n\n## Tech Stack\n- Python 3\n- PyQt5 (GUI framework)\n- ReportLab (PDF generation)\n- Azure SQL Database (`pyodbc`)\n- Email Notifications (`smtplib`)\n\n## Troubleshooting\n- If the database connection fails, ensure `ODBC Driver 17` is installed.\n- If emails fail to send, ensure SMTP settings allow external authentication.\n- Ensure PyQt5 is installed correctly for GUI functionality.\n"
      },
      {
        "filename": "main.py",
        "code": "import sys\nfrom PyQt5.QtWidgets import QApplication\nfrom ui import MainWindow\nfrom PyQt5.QtGui import QFont\nfrom PyQt5.QtGui import QIcon\nimport os\n\n# To package\n# pyinstaller --name ReturnsCheckIn --onefile --windowed --icon=RC.ico --add-data \"C:\\Users\\Alfredo\\Documents\\DevFolder\\new_code\\returns\\returns_app\\RC.ico;.\" main.py\n\n\ndef resource_path(relative_path):\n    \"\"\"Get absolute path to resource, works for dev and for PyInstaller\"\"\"\n    base_path = getattr(sys, \"_MEIPASS\", os.path.dirname(os.path.abspath(__file__)))\n    return os.path.join(base_path, relative_path)\n\n\ndef main():\n    app = QApplication(sys.argv)\n    global_font = QFont(\"Arial\", 18, QFont.Normal)\n    app.setWindowIcon(QIcon(resource_path(\"RC.ico\")))\n    app.setFont(global_font)\n    app.setStyleSheet(\n        \"\"\"\n    /* General background for the whole application */\n    QWidget {\n        background-color: #f0f0f0; /* Light Gray Background */\n        color: #333333; /* Dark Gray Text */\n    }\n\n    /* Button styles */\n    QPushButton {\n        background-color: #f39c12; /* Safety Orange Button */\n        color: white; /* White Text */\n        border: 1px solid #e67e22; /* Slightly darker orange border */\n        padding: 6px 12px; /* Padding inside the button */\n        border-radius: 0px; /* Rounded corners */\n    }\n    QPushButton:hover {\n        background-color: #e67e22; /* Darker Orange on Hover */\n    }\n    QPushButton:pressed {\n        background-color: #d35400; /* Even Darker Orange when pressed */\n    }\n\n    /* Label styles */\n    QLabel {\n        color: #333333; /* Dark Gray Text */\n        background-color: #f0f0f0; /* Same as background */\n    }\n\n    /* Combo Box styles */\n    QComboBox {\n        background-color: white; /* White background for combo box */\n        color: #333333; /* Dark Gray Text */\n        border: 1px solid #bdc3c7; /* Light Gray border */\n        padding: 4px; /* Padding inside the combo box */\n    }\n    QComboBox::drop-down {\n        border-left: 1px solid #bdc3c7; /* Separate drop-down button with a border */\n    }\n    QComboBox::down-arrow {\n        image: url(down_arrow_icon.png); /* Custom arrow icon */\n        width: 10px;\n        height: 10px;\n    }\n\n    /* Line Edit styles */\n    QLineEdit {\n        background-color: white; /* White background for line edit */\n        color: #333333; /* Dark Gray Text */\n        border: 1px solid #bdc3c7; /* Light Gray border */\n        padding: 4px; /* Padding inside the line edit */\n    }\n    QTextEdit {\n        background-color: white; /* White background for line edit */\n        color: #333333; /* Dark Gray Text */\n        border: 1px solid #bdc3c7; /* Light Gray border */\n        padding: 4px; /* Padding inside the line edit */\n    }\n\"\"\"\n    )\n    window = MainWindow()\n    window.show()\n    sys.exit(app.exec_())\n\n\nif __name__ == \"__main__\":\n    main()\n"
      },
      {
        "filename": ".gitIgnore",
        "code": "__pycache__/\nbuild/\ndist/\nenv/\n*.spec\n"
      },
      {
        "filename": "config.py",
        "code": "db_config = {\n    \"ExampleDb\": {\n        \"server\": \"example.database.windows.net\",\n        \"database\": \"ExampleDb\",\n        \"username\": \"example\",\n        \"password\": \"example\",\n        \"driver\": \"{ODBC Driver 17 for SQL Server}\",\n        \"port\": 1433,  # Default port for SQL Server\n    },\n}\n\n\ndef create_connection_string(server_config):\n    return (\n        f\"DRIVER={server_config['driver']};\"\n        f\"SERVER={server_config['server']};\"\n        f\"PORT={server_config[\"port\"]};DATABASE={server_config['database']};\"\n        f\"UID={server_config['username']};\"\n        f\"PWD={server_config['password']}\"\n    )\n\n\nSENDER_EMAIL = \"sender_email@domain.com\"\nSENDER_PASSWORD = \"sender_password\"\nRECIPIENT_EMAILS = [\n    \"recipient_email_1@domain.com\",\n    \"recipient_email_2@domain.com\",\n]  # List of emails to send the report\n"
      },
      {
        "filename": "email_helper.py",
        "code": "import smtplib\nfrom email.message import EmailMessage\nfrom config import SENDER_EMAIL, SENDER_PASSWORD, RECIPIENT_EMAILS\nimport os\nimport getpass\nimport socket\n\n\ndef send_email(subject, body):\n    current_dir = os.getcwd()\n    folder_name = os.path.basename(current_dir)\n    computer_name = socket.gethostname()\n    user_name = getpass.getuser()\n    new_line = \"\\n\"\n    body_with_new_line = (\n        f\"{body}{new_line}{folder_name} on {computer_name} ({user_name})\"\n    )\n    msg = EmailMessage()\n    msg.set_content(body_with_new_line)\n    msg[\"Subject\"] = f\"{subject} : {folder_name}\"\n    msg[\"From\"] = SENDER_EMAIL\n    msg[\"To\"] = \", \".join(RECIPIENT_EMAILS)\n\n    try:\n        with smtplib.SMTP_SSL(\"smtp.gmail.com\", 465) as server:\n            server.login(SENDER_EMAIL, SENDER_PASSWORD)\n            server.send_message(msg)\n        print(\"Email sent successfully.\")\n    except Exception as e:\n        print(f\"Error sending email: {e}\")\n"
      },
      {
        "filename": "example_db.py",
        "code": "import pyodbc\nfrom config import create_connection_string, db_config\nfrom datetime import datetime\nimport socket\n\n\nclass ExampleDb:\n    def __init__(self):\n        self.conn = None\n        self.cursor = None\n        self.connect()\n\n    def connect(self):\n        \"\"\"Establish a new connection to the database.\"\"\"\n        self.conn = pyodbc.connect(create_connection_string(db_config[\"ExampleDb\"]))\n        self.cursor = self.conn.cursor()\n\n    def check_if_connected(self):\n        \"\"\"Check if the database connection is active.\"\"\"\n        try:\n            self.cursor.execute(\"SELECT 1\")\n            return True\n        except (pyodbc.ProgrammingError, pyodbc.OperationalError):\n            return False\n\n    def reconnect(self):\n        \"\"\"Reconnect to the database if the connection is lost.\"\"\"\n        if not self.check_if_connected():\n            self.connect()\n\n    def get_pallet_note(self, tracking_number):\n        \"\"\"Check if a return has a pallet note.\"\"\"\n        self.cursor.execute(\n            \"\"\"\n            SELECT pallet_note FROM ReturnPalletNotes WHERE tracking_number = ?\n            \"\"\",\n            tracking_number,\n        )\n        result = self.cursor.fetchone()\n        if result:\n            return result[0]\n        else:\n            self.insert_pallet_note(tracking_number, \"\")\n            return \"\"\n\n    def insert_pallet_note(self, tracking_number, pallet_note):\n        \"\"\"Inserts new pallet note.\"\"\"\n        self.cursor.execute(\n            \"\"\"\n            INSERT INTO ReturnPalletNotes (tracking_number, pallet_note) VALUES (?, ?)\n            \"\"\",\n            tracking_number,\n            pallet_note,\n        )\n        self.conn.commit()\n\n    def update_pallet_note(self, tracking_number, pallet_note):\n        \"\"\"Update pallet note.\"\"\"\n        self.cursor.execute(\n            \"\"\"\n            UPDATE ReturnPalletNotes SET pallet_note = ? WHERE tracking_number = ?\n            \"\"\",\n            pallet_note,\n            tracking_number,\n        )\n        self.conn.commit()\n\n    def search_tracking_number(self, tracking_number):\n        \"\"\"Search for a tracking number in the database.\"\"\"\n        tracking_number.upper()\n        self.cursor.execute(\n            \"\"\"\n            SELECT id, return_id_number, sku, po, received, status, note FROM Returns \n            WHERE tracking_number = ?\n            \"\"\",\n            tracking_number,\n        )\n        results = []\n        try:\n            for row in self.cursor.fetchall():\n                if not row.status:\n                    row.status = \"Select Status\"\n                if not row.note:\n                    row.note = \"\"\n\n                results.append(\n                    {\n                        \"id\": row.id,\n                        \"return_id_number\": row.return_id_number,\n                        \"sku\": f\"{row.sku}@{row.po}\",\n                        \"received\": row.received,\n                        \"status\": row.status,\n                        \"note\": row.note,\n                    }\n                )\n\n        except pyodbc.ProgrammingError:\n            return None\n\n        if not results:\n            return None\n\n        results_tuples = []\n        for result in results:\n            result[\"components\"] = self.get_components(result[\"id\"])\n            result[\"wrong_parts\"] = self.get_wrong_parts(result[\"id\"])\n            result[\"expected_sku_amount\"] = self.get_expected_sku_amount(\n                result[\"return_id_number\"]\n            )\n            result[\"sku_amount_received\"] = self.get_skus_received(\n                result[\"return_id_number\"]\n            )\n            results_tuples.append(self.return_tuple(result))\n\n        return results_tuples\n\n    def return_tuple(self, result):\n        if result[\"wrong_parts\"]:\n            return (\n                result[\"sku\"],\n                result[\"return_id_number\"],\n                result[\"expected_sku_amount\"],\n                result[\"sku_amount_received\"],\n                result[\"status\"],\n                result[\"note\"],\n                result[\"received\"],\n                result[\"components\"],\n                result[\"wrong_parts\"],\n            )\n        return (\n            result[\"sku\"],\n            result[\"return_id_number\"],\n            result[\"expected_sku_amount\"],\n            result[\"sku_amount_received\"],\n            result[\"status\"],\n            result[\"note\"],\n            result[\"received\"],\n            result[\"wrong_parts\"],\n            result[\"components\"],\n        )\n\n    def get_components(self, id):\n        self.cursor.execute(\n            \"\"\"\n            SELECT parts, condition FROM ReturnItems \n            WHERE return_id = ?\n            \"\"\",\n            id,\n        )\n        components = {}\n        for row in self.cursor.fetchall():\n            if not row.condition:\n                row.condition = \"Good\"\n            components[row.parts] = row.condition\n        return components\n\n    def get_wrong_parts(self, id):\n        self.cursor.execute(\n            \"\"\"\n            SELECT parts, condition FROM ReturnWrongItemsReceived \n            WHERE return_id = ?\n            \"\"\",\n            id,\n        )\n        wrong_parts = {row.parts: row.condition for row in self.cursor.fetchall()}\n        return wrong_parts\n\n    def get_expected_sku_amount(self, return_id_number):\n        self.cursor.execute(\n            \"\"\"\n            SELECT count(*) FROM Returns\n            WHERE return_id_number = ?\n            \"\"\",\n            return_id_number,\n        )\n        expected_sku_amount = self.cursor.fetchone()[0]\n        return expected_sku_amount\n\n    def get_skus_received(self, return_id_number):\n        self.cursor.execute(\n            \"\"\"\n            SELECT count(*) FROM Returns\n            WHERE return_id_number = ? and received = 1\n            \"\"\",\n            return_id_number,\n        )\n        sku_amount_received = self.cursor.fetchone()[0]\n        return sku_amount_received\n\n    def check_in_return(self, tracking_number, status, note, sku, components):\n        \"\"\"Check in a return to the database.\"\"\"\n\n        try:\n            sku_and_po = sku.split(\"@\")\n            sku = sku_and_po[0]\n            po = sku_and_po[1]\n\n            if self.it_has_wrong_parts(tracking_number, sku, po):\n                self.delete_wrong_parts(tracking_number, sku, po)\n\n            checkin_station = socket.gethostname()\n\n            self.cursor.execute(\n                \"\"\"\n                UPDATE Returns SET received = 1, received_date= ?, status = ?, note = ?, checkin_station = ? WHERE tracking_number = ? AND sku = ? AND po = ?\n                \"\"\",\n                datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                status,\n                note,\n                checkin_station,\n                tracking_number,\n                sku,\n                po,\n            )\n\n            self.conn.commit()\n\n            if status == \"Wrong Part\":\n                components_data = [\n                    (tracking_number, sku, po, component, condition)\n                    for component, condition in components.items()\n                ]\n                self.cursor.executemany(\n                    \"\"\"\n                    INSERT INTO ReturnWrongItemsReceived (return_id, parts, condition) VALUES ((SELECT id FROM Returns WHERE tracking_number = ? AND sku = ? AND po = ?), ?, ?)\n                    \"\"\",\n                    components_data,\n                )\n\n                self.conn.commit()\n\n            else:\n\n                components_data = [\n                    (condition, tracking_number, sku, po, component)\n                    for component, condition in components.items()\n                ]\n                self.cursor.executemany(\n                    \"\"\"\n                    UPDATE ReturnItems SET condition = ? WHERE return_id = (SELECT id FROM Returns WHERE tracking_number = ? AND  sku = ? AND po= ?) AND parts = ?\n                    \"\"\",\n                    components_data,\n                )\n\n                self.conn.commit()\n\n        except pyodbc.IntegrityError:\n            return False\n\n        return True\n\n    def it_has_wrong_parts(self, tracking_number, sku, po):\n        \"\"\"Check if a return is a wrong part return.\"\"\"\n        self.cursor.execute(\n            \"\"\"\n            SELECT status FROM Returns WHERE tracking_number = ? AND sku = ? AND po = ?\n            \"\"\",\n            tracking_number,\n            sku,\n            po,\n        )\n        try:\n            result = self.cursor.fetchone()[0]\n        except TypeError:\n            return False\n\n        return result == \"Wrong Part\"\n\n    def delete_wrong_parts(self, tracking_number, sku, po):\n        \"\"\"Delete wrong parts from the database.\"\"\"\n        self.cursor.execute(\n            \"\"\"\n            DELETE FROM ReturnWrongItemsReceived WHERE return_id = (SELECT id FROM Returns WHERE tracking_number = ? AND sku = ? AND po = ?)\n            \"\"\",\n            tracking_number,\n            sku,\n            po,\n        )\n        self.conn.commit()\n\n    def verify_sku(self, sku):\n        \"\"\"Verify if a SKU is in the database.\"\"\"\n        self.cursor.execute(\n            \"\"\"\n            SELECT component FROM components WHERE sku = ?\n            \"\"\",\n            sku,\n        )\n        result = {}\n        for row in self.cursor.fetchall():\n            if row[0] is not None:\n                result[row[0]] = None\n            else:\n                result[sku] = None\n\n        return result\n\n    def get_sku_component_map(self):\n        \"\"\"Inserts the sales data into the Sales database.\"\"\"\n        self.spinner.start(\n            \"Getting SKU ASIN Component Map from the Product Catalog database\"\n        )\n        try:\n            self.cursor.execute(\n                \"select * from vProductAndAliasWithComponentsView\",\n            )\n            sku_component_map = {}\n            for row in self.cursor:\n                if row.component is not None and row.sku not in sku_component_map:\n                    sku_component_map[row.sku] = [row.component]\n                elif row.component is not None and row.sku in sku_component_map:\n                    sku_component_map[row.sku].append(row.component)\n\n            return sku_component_map\n\n        except pyodbc.Error as e:\n            print(f\"Error inserting sales FBA sales data: {e}\")\n            raise\n\n    def close(self):\n        \"\"\"Close the database connection.\"\"\"\n        if self.conn:\n            self.conn.close()\n            self.conn = None\n            self.cursor = None\n\n\nex_db = ExampleDb()\n"
      },
      {
        "filename": "label_updater.py",
        "code": "from PyQt5.QtCore import QThread, pyqtSignal\n\n\nclass LabelUpdater(QThread):\n    update_done = pyqtSignal(object)  # Signal to emit when the task is done\n    update_failed = pyqtSignal(str)  # Signal to emit if the task fails\n\n    def __init__(self, func, args=()):\n        super().__init__()\n        self.func = func\n        self.args = args\n\n    def run(self):\n        try:\n            result = self.func(*self.args)\n            self.update_done.emit(result)  # Emit the result when done\n        except Exception as e:\n            self.update_failed.emit(str(e))  # Emit the error if something fails\n"
      },
      {
        "filename": "main.py",
        "code": "import sys\nfrom PyQt5.QtWidgets import QApplication\nfrom ui import MainWindow\nfrom PyQt5.QtGui import QFont\nfrom PyQt5.QtGui import QIcon\nimport os\n\n# To package\n# pyinstaller --name ReturnsCheckIn --onefile --windowed --icon=RC.ico --add-data \"C:\\Users\\Alfredo\\Documents\\DevFolder\\new_code\\returns\\returns_app\\RC.ico;.\" main.py\n\n\ndef resource_path(relative_path):\n    \"\"\"Get absolute path to resource, works for dev and for PyInstaller\"\"\"\n    base_path = getattr(sys, \"_MEIPASS\", os.path.dirname(os.path.abspath(__file__)))\n    return os.path.join(base_path, relative_path)\n\n\ndef main():\n    app = QApplication(sys.argv)\n    global_font = QFont(\"Arial\", 18, QFont.Normal)\n    app.setWindowIcon(QIcon(resource_path(\"RC.ico\")))\n    app.setFont(global_font)\n    app.setStyleSheet(\n        \"\"\"\n    /* General background for the whole application */\n    QWidget {\n        background-color: #f0f0f0; /* Light Gray Background */\n        color: #333333; /* Dark Gray Text */\n    }\n\n    /* Button styles */\n    QPushButton {\n        background-color: #f39c12; /* Safety Orange Button */\n        color: white; /* White Text */\n        border: 1px solid #e67e22; /* Slightly darker orange border */\n        padding: 6px 12px; /* Padding inside the button */\n        border-radius: 0px; /* Rounded corners */\n    }\n    QPushButton:hover {\n        background-color: #e67e22; /* Darker Orange on Hover */\n    }\n    QPushButton:pressed {\n        background-color: #d35400; /* Even Darker Orange when pressed */\n    }\n\n    /* Label styles */\n    QLabel {\n        color: #333333; /* Dark Gray Text */\n        background-color: #f0f0f0; /* Same as background */\n    }\n\n    /* Combo Box styles */\n    QComboBox {\n        background-color: white; /* White background for combo box */\n        color: #333333; /* Dark Gray Text */\n        border: 1px solid #bdc3c7; /* Light Gray border */\n        padding: 4px; /* Padding inside the combo box */\n    }\n    QComboBox::drop-down {\n        border-left: 1px solid #bdc3c7; /* Separate drop-down button with a border */\n    }\n    QComboBox::down-arrow {\n        image: url(down_arrow_icon.png); /* Custom arrow icon */\n        width: 10px;\n        height: 10px;\n    }\n\n    /* Line Edit styles */\n    QLineEdit {\n        background-color: white; /* White background for line edit */\n        color: #333333; /* Dark Gray Text */\n        border: 1px solid #bdc3c7; /* Light Gray border */\n        padding: 4px; /* Padding inside the line edit */\n    }\n    QTextEdit {\n        background-color: white; /* White background for line edit */\n        color: #333333; /* Dark Gray Text */\n        border: 1px solid #bdc3c7; /* Light Gray border */\n        padding: 4px; /* Padding inside the line edit */\n    }\n\"\"\"\n    )\n    window = MainWindow()\n    window.show()\n    sys.exit(app.exec_())\n\n\nif __name__ == \"__main__\":\n    main()\n"
      },
      {
        "filename": "pallet_form.py",
        "code": "import tempfile\nimport os\nimport time\nfrom reportlab.lib.pagesizes import letter\nfrom reportlab.lib import colors\nfrom reportlab.lib.units import inch\nfrom reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer\nfrom reportlab.lib.styles import getSampleStyleSheet\nfrom reportlab.graphics.shapes import Drawing, Rect\nfrom email_helper import send_email\nimport traceback\n\n\ndef create_pdf_report(filename, return_id_number, tracking_number, results):\n    \"\"\"Create a temporary PDF report for printing.\"\"\"\n    # Create a PDF document\n    pdf_file = SimpleDocTemplate(filename, pagesize=letter)\n\n    # Set up a stylesheet and styles for the document\n    styles = getSampleStyleSheet()\n    elements = []\n\n    # Define the main header data\n    header_data = [\n        [\"Return Id Number:\", return_id_number],\n        [\"Tracking Number:\", tracking_number],\n        [\"Source:\", \"Amazon Vendor\"],\n    ]\n\n    # Add the header to the document\n    for row in header_data:\n        elements.append(Paragraph(f\"{row[0]} {row[1]}\", styles[\"Normal\"]))\n\n    # Add space between the header and the tables\n    elements.append(Spacer(1, 12))  # 12 points space\n\n    # Helper function to create a simulated checkbox\n    def create_checkbox():\n        d = Drawing(10, 10)\n        d.add(\n            Rect(\n                0,\n                0,\n                10,\n                10,\n                strokeWidth=1,\n                strokeColor=colors.black,\n                fillColor=colors.white,\n            )\n        )\n        return d\n\n    # Process SKUs and components\n    for result in results:\n        sku = sku_cleanner(result[0])\n        components = [component for component, _ in result[-1].items()]\n\n        # SKU Header\n        sku_header = [[\"Sku\", \"Complete\", \"Incomplete\", \"Wrong Product\", \"Wrong Part\"]]\n        components_header = [[\"Components\", \"Good\", \"Damaged\", \"Missing\"]]\n\n        # Add SKU and components table for each SKU\n        data = [\n            sku_header[0],\n            [\n                sku,\n                create_checkbox(),\n                create_checkbox(),\n                create_checkbox(),\n                create_checkbox(),\n            ],\n            components_header[0],\n        ]\n\n        for component in components:\n            data.append(\n                [component, create_checkbox(), create_checkbox(), create_checkbox()]\n            )\n\n        # Create table with consistent column widths\n        table = Table(data, colWidths=[1.5 * inch] + [1 * inch] * 4)\n\n        # Add style to prevent table splitting across pages\n        table.setStyle(\n            TableStyle(\n                [\n                    (\"BACKGROUND\", (0, 0), (-1, 0), colors.grey),\n                    (\"TEXTCOLOR\", (0, 0), (-1, 0), colors.whitesmoke),\n                    (\"ALIGN\", (0, 0), (-1, -1), \"CENTER\"),\n                    (\"FONTNAME\", (0, 0), (-1, 0), \"Helvetica-Bold\"),\n                    (\"BOTTOMPADDING\", (0, 0), (-1, 0), 12),\n                    (\"BACKGROUND\", (0, 1), (-1, 1), colors.beige),\n                    (\"GRID\", (0, 0), (-1, -1), 1, colors.black),\n                    (\n                        \"SPLITTABLE\",\n                        (0, 0),\n                        (-1, -1),\n                        False,\n                    ),  # Prevent table from splitting\n                ]\n            )\n        )\n\n        elements.append(table)\n        elements.append(Spacer(1, 12))  # Add space between tables\n\n    # Build the PDF\n    pdf_file.build(elements)\n\n\ndef try_delete_file(pdf_filename, max_retries=5, delay=2):\n    \"\"\"Attempt to delete the PDF file, retrying if the file is in use.\"\"\"\n    retries = 0\n    while retries < max_retries:\n        try:\n            os.remove(pdf_filename)\n            print(f\"Temporary PDF file {pdf_filename} has been deleted.\")\n            return\n        except PermissionError:\n            print(f\"File is still in use. Retrying deletion in {delay} seconds...\")\n            time.sleep(delay)\n            retries += 1\n    print(\n        f\"Failed to delete the temporary PDF file {pdf_filename} after {max_retries} attempts.\"\n    )\n\n\ndef sku_cleanner(sku):\n    sku_and_po = sku.split(\"@\")\n    return sku_and_po[0]\n\n\ndef generate_and_print_pdf(\n    return_id_number, tracking_number, results, delay_before_delete=3\n):\n    \"\"\"Generate the PDF, print it, and delete it after printing.\"\"\"\n    try:\n        # Create a temporary file for the PDF\n        with tempfile.NamedTemporaryFile(suffix=\".pdf\", delete=False) as tmp_pdf:\n            pdf_filename = tmp_pdf.name\n\n        try:\n            # Create the PDF\n            create_pdf_report(pdf_filename, return_id_number, tracking_number, results)\n\n            # Print the PDF using the default viewer\n            os.startfile(pdf_filename, \"print\")\n\n            # Add a delay to ensure printing has started before deleting the file\n            time.sleep(delay_before_delete)  # Wait before trying to delete\n\n        finally:\n            # After the delay, try to delete the temporary PDF file with retries\n            try_delete_file(pdf_filename)\n\n    except Exception as e:\n        send_email(send_email(\"Unexpected Error\", traceback.format_exc()))\n\n\n# from openpyxl import Workbook\n# from openpyxl.styles import Font, PatternFill, Border, Side\n# from openpyxl.utils import get_column_letter\n# from openpyxl.worksheet.pagebreak import Break\n# import win32com.client as win32\n# import os\n\n\n# def auto_adjust_column_width(ws):\n#     \"\"\"Automatically adjust the column widths based on the content.\"\"\"\n#     for col in ws.columns:\n#         max_length = 0\n#         col_letter = get_column_letter(col[0].column)  # Get the column letter\n#         for cell in col:\n#             if cell.value:\n#                 max_length = max(max_length, len(str(cell.value)))\n#         # Set column width slightly larger than the max length\n#         ws.column_dimensions[col_letter].width = max_length + 2\n\n\n# def is_row_empty(ws, row_number):\n#     \"\"\"Check if a row is empty.\"\"\"\n#     for cell in ws[row_number]:\n#         if cell.value is not None:\n#             return False\n#     return True\n\n\n# def insert_page_break(ws, row_number):\n#     \"\"\"Insert a manual page break at the specified row.\"\"\"\n#     ws.row_breaks.append(Break(id=row_number))  # Add a horizontal page break\n\n\n# def print_last_n_rows(ws, n):\n#     \"\"\"Print the last N rows of the worksheet.\"\"\"\n#     total_rows = ws.max_row  # Get the total number of rows\n#     start_row = max(1, total_rows - n + 1)  # Determine the starting row for printing\n\n#     # Loop through the rows from the start_row to the last row\n#     for row in ws.iter_rows(min_row=start_row, max_row=total_rows, values_only=True):\n#         print([cell for cell in row])\n\n\n# def create_custom_excel_and_print(return_id_number, tracking_number, results):\n#     \"\"\"Create an Excel sheet with custom data, print with preview, and handle page breaks.\"\"\"\n#     # Create a workbook and add a worksheet\n#     wb = Workbook()\n#     ws = wb.active\n#     ws.title = \"ReturnsCheck\"\n\n#     # Define styles\n#     header_font = Font(bold=True)\n#     sku_fill = PatternFill(start_color=\"FFC7CE\", end_color=\"FFC7CE\", fill_type=\"solid\")\n#     component_fill = PatternFill(\n#         start_color=\"C6EFCE\", end_color=\"C6EFCE\", fill_type=\"solid\"\n#     )\n#     thin_border = Border(\n#         left=Side(style=\"thin\"),\n#         right=Side(style=\"thin\"),\n#         top=Side(style=\"thin\"),\n#         bottom=Side(style=\"thin\"),\n#     )\n\n#     # Define the main header\n#     main_header = [\n#         [\"Return Id Number:\", return_id_number],\n#         [\"Tracking Number:\", tracking_number],\n#         [\"Source:\", \"Amazon Vendor\"],\n#     ]\n\n#     # Add the main header to the worksheet\n#     for row in main_header:\n#         ws.append(row)\n#         for cell in ws[ws.max_row]:  # Use ws.max_row to get the last row\n#             cell.font = header_font\n\n#     # Add space between the main header and the table\n#     ws.append([])\n\n#     # Define the table headers\n#     sku_header = [\n#         \"Sku\",\n#         \"Complete\",\n#         \"Incomplete\",\n#         \"Wrong Product\",\n#         \"Wrong Part\",\n#     ]\n#     components_header = [\"Components\", \"Good\", \"Damaged\", \"Missing\"]\n\n#     # Add empty rows\n#     ws.append([])\n\n#     # # Start with page 1\n#     # page_number = 1\n#     # max_rows_per_page = 44  # Maximum rows allowed per page\n\n#     # Process SKUs and components\n#     for result_index, result in enumerate(results):\n#         sku = result[0]\n#         components = [component for component, _ in result[-1].items()]\n\n#         # lines_it_will_add = 2 + len(components) + 1 + 1  # Rows to be added\n\n#         # # Insert a manual page break if the next section will exceed the page limit\n#         # if ws.max_row + lines_it_will_add > (max_rows_per_page * page_number):\n#         #     insert_page_break(ws, ws.max_row)\n#         #     page_number += 1\n\n#         ws.append([])  # Add space before each SKU section\n#         ws.append(sku_header)  # Add SKU header\n#         for cell in ws[ws.max_row]:  # Use ws.max_row to get the last row\n#             cell.fill = sku_fill  # Color code SKU header\n#             cell.font = header_font\n#             cell.border = thin_border\n\n#         # Add the SKU row with empty checkboxes\n#         ws.append([sku, \"☐\", \"☐\", \"☐\", \"☐\"])\n#         for cell in ws[ws.max_row]:  # Use ws.max_row to get the last row\n#             cell.border = thin_border\n\n#         # Add the component headers\n#         ws.append(components_header)\n#         for cell in ws[ws.max_row]:  # Use ws.max_row to get the last row\n#             cell.fill = component_fill  # Color code component header\n#             cell.font = header_font\n#             cell.border = thin_border\n\n#         # Add the components data with empty checkboxes\n#         for component in components:\n#             ws.append([component, \"☐\", \"☐\", \"☐\"])\n#             for cell in ws[ws.max_row]:  # Use ws.max_row to get the last row\n#                 cell.border = thin_border\n\n#         # Add an empty row after each section\n#         ws.append([])\n\n#         # print_last_n_rows(ws, lines_it_will_add)\n\n#         # # Insert a manual page break if the next section will exactly fill the page\n#         # if ws.max_row + lines_it_will_add == (max_rows_per_page * page_number):\n#         #     insert_page_break(ws, ws.max_row)\n#         #     page_number += 1\n\n#     # Adjust column widths to fit the content\n#     auto_adjust_column_width(ws)\n\n#     # # Page layout settings to ensure proper page breaks\n#     # ws.page_setup.orientation = ws.ORIENTATION_PORTRAIT\n#     # ws.page_setup.paperSize = ws.PAPERSIZE_LETTER  # Letter size\n#     # ws.page_margins.left = 0.5  # Adjust margins to prevent content overflow\n#     # ws.page_margins.right = 0.5\n#     # ws.page_margins.top = 0.75\n#     # ws.page_margins.bottom = 0.75\n#     # ws.page_margins.header = 0.5\n#     # ws.page_margins.footer = 0.5\n\n#     # Save the workbook to a temporary file\n#     temp_file_path = os.path.join(os.getcwd(), \"temp_excel_file.xlsx\")\n#     wb.save(temp_file_path)\n\n#     # Use Excel to open the file and show print preview\n#     excel = win32.Dispatch(\"Excel.Application\")\n#     excel.Visible = True  # Show Excel window\n\n#     # Open the workbook in Excel\n#     workbook = excel.Workbooks.Open(temp_file_path)\n\n#     try:\n#         # Show the print preview dialog\n#         workbook.PrintOut()  # Shows print preview dialog\n#         pass\n#     except Exception as e:\n#         print(f\"Error printing the file: {e}\")\n#     finally:\n#         # Close the workbook and Excel\n#         workbook.Close(False)\n#         excel.Quit()\n\n#     # Optionally, clean up the temporary file\n#     os.remove(temp_file_path)\n"
      },
      {
        "filename": "ui.py",
        "code": "from PyQt5.QtWidgets import (\n    QMainWindow,\n    QLabel,\n    QLineEdit,\n    QPushButton,\n    QComboBox,\n    QVBoxLayout,\n    QHBoxLayout,\n    QWidget,\n    QSizePolicy,\n    QApplication,\n    QToolTip,\n    QDesktopWidget,\n    QTextEdit,\n    QScrollArea,\n    QDialog,\n)\nfrom PyQt5.QtGui import QFont, QIcon, QTextCursor\nfrom PyQt5.QtCore import Qt, pyqtSignal, QTimer\nfrom example_db import ReturnsDb\nimport os\nimport sys\nfrom label_updater import LabelUpdater\nfrom pallet_form import generate_and_print_pdf\n\n\ndef resource_path(relative_path):\n    \"\"\"Get absolute path to resource, works for dev and for PyInstaller\"\"\"\n    base_path = getattr(sys, \"_MEIPASS\", os.path.dirname(os.path.abspath(__file__)))\n    return os.path.join(base_path, relative_path)\n\n\nclass PalletNoteDialog(QDialog):\n    def __init__(self, initial_text=\"\", parent=None):\n        super().__init__(parent)\n        self.setWindowTitle(\"Pallet Note\")\n        self.character_limit = 500  # Set the character limit\n\n        # Create layout\n        layout = QVBoxLayout(self)\n\n        # Label\n        self.label = QLabel(\"Pallet Note\")\n        layout.addWidget(self.label)\n\n        # Scrollable text field\n        self.text_edit = QTextEdit(self)\n        self.text_edit.setPlainText(initial_text)\n        self.text_edit.textChanged.connect(self.update_character_count)\n        layout.addWidget(self.text_edit)\n\n        # Character count label\n        self.char_count_label = QLabel(f\"0/{self.character_limit} characters\")\n        layout.addWidget(self.char_count_label)\n\n        # Buttons layout\n        button_layout = QHBoxLayout()\n\n        # Save button\n        self.save_button = QPushButton(\"Save\")\n        self.save_button.clicked.connect(self.accept)\n        button_layout.addWidget(self.save_button)\n\n        # Cancel button\n        self.cancel_button = QPushButton(\"Cancel\")\n        self.cancel_button.clicked.connect(self.reject)\n        button_layout.addWidget(self.cancel_button)\n\n        layout.addLayout(button_layout)\n        self.update_character_count()  # Update character count initially\n\n    def update_character_count(self):\n        \"\"\"\n        Updates the character count label and limits input to the character limit.\n        \"\"\"\n        current_text = self.text_edit.toPlainText()\n        current_length = len(current_text)\n\n        # If text exceeds character limit, truncate it\n        if current_length > self.character_limit:\n            self.text_edit.setPlainText(current_text[: self.character_limit])\n            # Move the cursor to the end after truncation\n            self.text_edit.moveCursor(QTextCursor.End)\n            current_length = self.character_limit\n\n        # Update the character count label\n        self.char_count_label.setText(\n            f\"{current_length}/{self.character_limit} characters\"\n        )\n\n    def get_text(self):\n        \"\"\"\n        Returns the text from the text edit field.\n        \"\"\"\n        return self.text_edit.toPlainText()\n\n\nclass CustomLineEdit(QLineEdit):\n    def keyPressEvent(self, event):\n        # Check if the pressed key is the Group Separator (ASCII 29)\n        if event.text() == chr(29):\n            # Clear the line edit\n            self.clear()\n        else:\n            # Call the base class method to handle other key presses\n            super().keyPressEvent(event)\n\n\nclass ClickableLabel(QLabel):\n    clicked = pyqtSignal(int)  # Signal to emit the index when the label is clicked\n\n    def __init__(self, index, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.index = index\n\n    def mousePressEvent(self, event):\n        self.clicked.emit(self.index)  # Emit the clicked signal with the index\n        super().mousePressEvent(event)\n\n\nclass MainWindow(QMainWindow):\n    def __init__(self):\n        super().__init__()\n\n        # Global varibles\n        self.db = ReturnsDb()\n        self.fields_min_height = 60\n        self.tracking_font = QFont(\"Arial\", 32, QFont.Bold)\n        self.tracking_min_height = 90\n        self.current_tracking_number_was_checked_in = False\n        self.do_not_update_state = False\n        self.current_search_results = None\n        self.originally_wrong_parts = False\n        self.originally_wrong_product = False\n        self.results = None\n        self.current_result_index = 0\n        self.current_tracking_number = None\n        self.sku_status_labels = {}\n        self.sku_selected_labels = {}\n        self.is_pallet = False\n        self.current_pallet_note = None\n\n        self.setWindowIcon(QIcon(resource_path(\"RC.ico\")))\n        self.setWindowTitle(\"Returns Check-In V2.3\")\n\n        # Create the main horizontal layout\n        self.main_layout = QVBoxLayout()\n        self.main_layout.setSpacing(30)\n        self.main_layout.setContentsMargins(40, 40, 40, 40)\n\n        # Header section-----------------------------------------\n        # Create box layout for header section\n        header_layout = QHBoxLayout()\n        header_layout.setSpacing(5)\n\n        # Create a label for sucessful check-in\n        self.check_in_label = QLabel()\n        # self.check_in_label.setMinimumHeight(self.check_in_label.fontMetrics().height())\n        self.check_in_label.setText(\" \")\n        self.check_in_label.setAlignment(Qt.AlignLeft)\n        check_in_label_color = \"color: green\"  # Green text color\n        self.check_in_label.setStyleSheet(check_in_label_color)\n        header_layout.addWidget(self.check_in_label)\n\n        # Create a label for the database connection status\n        self.db_label = QLabel(\"Connected to Database\")\n        db_label_color = \"color: green\"  # Green text color\n        self.db_label.setStyleSheet(db_label_color)\n        self.db_label.setAlignment(Qt.AlignRight)\n        header_layout.addWidget(self.db_label)\n\n        # Add the header layout to the main layout\n        self.main_layout.addLayout(header_layout)\n\n        # Tracking number section----------------------------------------------\n        # Create box layout for tracking number section\n        tracking_number_layout = QVBoxLayout()\n        tracking_number_layout.setSpacing(5)\n\n        # Create a label for tracking number\n        self.tracking_label = QLabel(\"Tracking Number:\")\n        self.tracking_label.setAlignment(Qt.AlignLeft)\n        tracking_number_layout.addWidget(self.tracking_label)\n\n        # Create a large text field for tracking number\n        self.tracking_number_field = CustomLineEdit(self)\n        self.tracking_font = self.tracking_font\n        self.tracking_number_field.setFont(self.tracking_font)\n        self.tracking_number_field.setPlaceholderText(\"Enter Tracking Number\")\n        self.tracking_number_field.setMinimumHeight(self.tracking_min_height)\n        self.tracking_number_field.setMinimumWidth(900)\n        self.tracking_number_field.returnPressed.connect(self.search_tracking_number)\n        tracking_number_layout.addWidget(self.tracking_number_field)\n\n        # Create a layout for the clear button\n        clear_button_layout = QVBoxLayout()\n        clear_button_layout.setSpacing(5)\n\n        # Create a space holder for the top of the clear button\n        self.clear_button_label_spacer = QLabel(\"\")\n        clear_button_layout.addWidget(self.clear_button_label_spacer)\n\n        # Create a button to clear the tracking number\n        self.clear_tracking_button = QPushButton(\"Clear\")\n        self.clear_tracking_button.setMinimumHeight(self.tracking_min_height)\n        self.clear_tracking_button.clicked.connect(self.clear_button_click)\n        clear_button_layout.addWidget(self.clear_tracking_button)\n\n        # Create horizontal layout for the tracking number and clear button\n        tracking_layout = QHBoxLayout()\n        tracking_layout.setSpacing(0)\n        tracking_layout.addLayout(tracking_number_layout)\n        tracking_layout.addLayout(clear_button_layout)\n\n        # Add the tracking layout to the main layout\n        self.main_layout.addLayout(tracking_layout)\n\n        # Drop Box section-----------------------------------------------------\n        # Create verticcal layout for the sku dropdown and its label\n        self.sku_layout = QVBoxLayout()\n        self.sku_layout.setSpacing(10)\n\n        # Create a label for SKU selection\n        self.sku_label = QLabel(\"SKU:\")\n        self.sku_label.setAlignment(Qt.AlignLeft)\n        self.sku_layout.addWidget(self.sku_label)\n\n        # Create a dropdown menu for SKU selection\n        self.sku_field = QLineEdit(self)\n        self.sku_field.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)\n        self.sku_field.setMinimumHeight(self.fields_min_height)\n        self.sku_field.setPlaceholderText(\"SKU\")\n        self.sku_field.returnPressed.connect(self.search_sku_button_click)\n        self.sku_field.setDisabled(True)\n        self.sku_layout.addWidget(self.sku_field)\n\n        # Create a layout for the search sku button\n        self.search_button_layout = QVBoxLayout()\n        # self.search_button_layout.setSpacing(5)\n\n        # Create a space holder for the top of the clear button\n        self.search_button_label_spacer = QLabel(\"\")\n        self.search_button_layout.addWidget(self.clear_button_label_spacer)\n\n        # Create a button to clear the tracking number\n        self.search_sku_button = QPushButton(\"Search\")\n        self.search_sku_button.setMinimumHeight(self.fields_min_height)\n        self.search_sku_button.clicked.connect(self.search_sku_button_click)\n        self.search_sku_button.setVisible(False)\n        self.search_button_layout.addWidget(self.search_sku_button)\n\n        self.sku_and_search_layout = QHBoxLayout()\n        self.sku_and_search_layout.setSpacing(0)\n        self.sku_and_search_layout.addLayout(self.sku_layout)\n        self.sku_and_search_layout.addLayout(self.search_button_layout)\n\n        # Create vertical layout for the status dropdown and its label\n        self.status_layout = QVBoxLayout()\n        self.status_layout.setSpacing(10)\n\n        # Create a label for status selection\n        self.status_label = QLabel(\"Select Status:\")\n        self.status_label.setAlignment(Qt.AlignLeft)\n        self.status_layout.addWidget(self.status_label)\n\n        # Create a dropdown menu for status selection\n        self.status_dropdown = QComboBox()\n        self.status_dropdown.addItems(\n            [\"Select Status\", \"Complete\", \"Incomplete\", \"Wrong Part\", \"Wrong Product\"]\n        )\n        self.status_dropdown.setDisabled(True)\n        self.status_dropdown.currentIndexChanged.connect(self.on_status_change)\n        self.status_dropdown.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)\n        self.status_dropdown.setMinimumHeight(self.fields_min_height)\n        self.status_layout.addWidget(self.status_dropdown)\n\n        # Create horizontal layout for the dropdowns\n        self.dropdown_layout = QHBoxLayout()\n        self.dropdown_layout.addLayout(self.sku_and_search_layout)\n        self.dropdown_layout.addLayout(self.status_layout)\n\n        # Add the dropdown layout to the main layout\n        self.main_layout.addLayout(self.dropdown_layout)\n\n        # Components section-------------------------------------------------\n        # SKU layout: container for SKU labels and dropdowns\n        self.sku_status_layout = QVBoxLayout()\n        # self.main_layout.addLayout(self.sku_status_layout)\n\n        # Create widgets and hide them initially (create enough for max SKUs you might have)\n        self.sku_widgets = (\n            []\n        )  # List to hold tuples of (label, dropdown, horizontal layout)\n\n        for _ in range(5):\n            # Horizontal layout for each SKU\n            h_layout = QHBoxLayout()\n\n            # SKU label\n            sku_label = QLabel(\"SKU\")\n            sku_label.setAlignment(Qt.AlignLeft)\n            h_layout.addWidget(sku_label)\n\n            # Dropdown for status\n            status_dropdown = QComboBox()\n            status_dropdown.setMinimumHeight(self.fields_min_height - 10)\n            status_dropdown.addItems([\"Good\", \"Damaged\", \"Missing\"])\n            status_dropdown.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)\n            status_dropdown.currentIndexChanged.connect(self.on_parts_condition_change)\n            h_layout.addWidget(status_dropdown)\n\n            # Add the horizontal layout to the vertical layout\n            self.sku_status_layout.addLayout(h_layout)\n\n            # Hide the widgets (not the layout)\n            sku_label.setVisible(False)\n            status_dropdown.setVisible(False)\n\n            # Store the widgets in a list for later access\n            self.sku_widgets.append((h_layout, sku_label, status_dropdown))\n\n        # Now wrap sku_status_layout in a widget\n        self.sku_status_widget = QWidget()\n        self.sku_status_widget.setLayout(self.sku_status_layout)\n\n        # Create a scroll area and add the widget to it\n        self.sku_scroll_area = QScrollArea()\n        self.sku_scroll_area.setMinimumHeight(250)\n        self.sku_scroll_area.setWidgetResizable(True)  # Allow resizing\n        self.sku_scroll_area.setWidget(\n            self.sku_status_widget\n        )  # Add the layout's widget to the scroll area\n\n        # # Add the scroll area to the main layout\n        # self.main_layout.addWidget(self.sku_scroll_area)\n\n        # Note section-------------------------------------------------------\n        # Create vertical layout for the note section\n        self.note_layout = QVBoxLayout()\n        self.note_layout.setSpacing(10)\n\n        # Create a label for the note\n        self.note_label = QLabel(\"Note:\")\n        self.note_label.setAlignment(Qt.AlignLeft)\n\n        # Create a text field for the note\n        self.note_field = QTextEdit()\n        self.note_field.setPlaceholderText(\"Enter Note\")\n        self.note_field.setMinimumHeight(self.fields_min_height)\n        self.note_field.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Minimum)\n        self.note_field.textChanged.connect(self.on_note_change)\n\n        # Create a layout for the note label and a pallet note button\n        self.pallet_note_layout = QHBoxLayout()\n        self.pallet_note_button = QPushButton(\"Create Pallet Note\")\n        self.pallet_note_button.setFixedSize(250, self.fields_min_height)\n        self.pallet_note_button.clicked.connect(self.open_pallet_note_dialog)\n        self.pallet_note_button.setVisible(False)\n\n        self.pallet_note_layout.addWidget(self.note_label)\n        self.pallet_note_layout.addWidget(self.pallet_note_button)\n\n        # self.note_layout.addWidget(self.note_label)\n        self.note_layout.addLayout(self.pallet_note_layout)\n        self.note_layout.addWidget(self.note_field)\n\n        # Create horizontal layout for the note and other sku\n        self.note_other_sku_layout = QHBoxLayout()\n        # self.note_other_sku_layout.addLayout(self.other_sku_layout)\n\n        self.note_other_sku_layout.addWidget(self.sku_scroll_area)\n        self.note_other_sku_layout.addLayout(self.note_layout)\n\n        # Add the note layout to the main layout\n        self.main_layout.addLayout(self.note_other_sku_layout)\n        # self.main_layout.addLayout(self.sku_status_layout)\n\n        # Information section------------------------------------------------\n        # Create vertical layout for the information section desciptions\n        self.info_labels_layout = QVBoxLayout()\n        self.info_labels_layout.setSpacing(5)\n\n        # Create a label for the information section description\n        self.auth_label = QLabel(\"Authorization ID:\")\n        self.auth_label.setAlignment(Qt.AlignLeft)\n\n        self.expected_label = QLabel(\"Expected Number of Skus:\")\n        self.expected_label.setAlignment(Qt.AlignLeft)\n\n        self.received_label = QLabel(\"Received Number of Skus:\")\n        self.received_label.setAlignment(Qt.AlignLeft)\n\n        # Add the information section descriptions to the layout\n        self.info_labels_layout.addWidget(self.auth_label)\n        self.info_labels_layout.addWidget(self.expected_label)\n        self.info_labels_layout.addWidget(self.received_label)\n\n        # Create vertical layout for the information section values\n        self.info_values_layout = QVBoxLayout()\n        self.info_values_layout.setSpacing(5)\n\n        # Create labels for the information values\n        self.auth_value = ClickableLabel(\" \")\n        self.auth_value.setAlignment(Qt.AlignRight)\n        self.auth_value.clicked.connect(self.copy_auth_value)\n\n        self.expected_value = QLabel(\" \")\n        self.expected_value.setAlignment(Qt.AlignRight)\n\n        self.received_value = QLabel(\" \")\n        self.received_value.setAlignment(Qt.AlignRight)\n\n        # Add the information section values to the layout\n        self.info_values_layout.addWidget(self.auth_value)\n        self.info_values_layout.addWidget(self.expected_value)\n        self.info_values_layout.addWidget(self.received_value)\n\n        # Create horizontal layout for the information section\n        self.info_layout = QHBoxLayout()\n\n        # Create the print checklist button\n        self.print_checklist_button = QPushButton(\"Print Checklist\")\n        self.print_checklist_button.setFixedSize(250, self.tracking_min_height)\n        self.print_checklist_button.clicked.connect(self.print_checklist)\n        self.print_checklist_button.setVisible(self.is_pallet)\n\n        self.info_layout.addWidget(self.print_checklist_button)\n        self.info_layout.addLayout(self.info_labels_layout)\n        self.info_layout.addLayout(self.info_values_layout)\n\n        # Add the information section layout to the main layout\n        self.main_layout.addLayout(self.info_layout)\n\n        # Button section-----------------------------------------------------\n        # Create a button\n        self.submit_button = QPushButton(\"Check In Return\")\n        self.submit_button.setFixedSize(\n            250, self.tracking_min_height\n        )  # Fixed size for the button\n        self.submit_button.clicked.connect(self.on_check_in)\n\n        # Create a layout just for the button to center it\n        self.button_layout = QHBoxLayout()\n        self.button_layout.setContentsMargins(0, 0, 0, 20)\n        self.button_layout.addStretch()  # Add stretchable space before the button\n        self.button_layout.addWidget(self.submit_button)\n        self.button_layout.addStretch()  # Add stretchable space after the button\n\n        # Add the button layout to the main layout\n        self.main_layout.addLayout(self.button_layout)\n\n        # Pallet section-----------------------------------------------------\n        # Initialize the pallet layout\n        self.pallet_layout = QVBoxLayout()\n        self.pallet_layout.setSpacing(10)\n        self.pallet_widget = QWidget()\n        self.pallet_widget.setLayout(self.pallet_layout)\n\n        # Create the scroll area for the pallet layout\n        self.pallet_scroll_area = QScrollArea()\n        self.pallet_scroll_area.setWidgetResizable(True)\n        self.pallet_scroll_area.setWidget(self.pallet_widget)\n        self.pallet_scroll_area.setMinimumHeight(200)\n        self.pallet_scroll_area.setMinimumWidth(450)\n        self.pallet_scroll_area.setVisible(False)\n\n        # Set the layout to a central widget\n        central_widget = QWidget()\n        main_layout_wrapper = QHBoxLayout()\n        main_layout_wrapper.addLayout(self.main_layout)\n        main_layout_wrapper.addWidget(self.pallet_scroll_area)\n        central_widget.setLayout(main_layout_wrapper)\n        self.setCentralWidget(central_widget)\n\n        # Center the window\n        # self.center()\n\n    # Checking in the return ------------------------------------------------------------------\n\n    def on_check_in(self):\n        if self.check_db_connection():\n            tracking_number = self.tracking_number_field.text()\n\n            if self.is_pallet:\n                if self.ready_to_click_next():\n\n                    not_updated = []\n                    for result in self.results:\n                        status = result[4]\n                        note = result[5]\n                        sku = result[0]\n                        components = result[-1]\n                        conditions = [condition for _, condition in components.items()]\n                        if \"green\" in self.sku_status_labels[sku].styleSheet():\n                            successfull = self.db.check_in_return(\n                                tracking_number, status, note, sku, components\n                            )\n                            if not successfull:\n                                not_updated.append(sku)\n\n                    self.db.update_pallet_note(\n                        tracking_number, self.current_pallet_note\n                    )\n\n                    if not not_updated:\n                        self.check_in_label.setStyleSheet(\"color: green\")\n                        self.check_in_label.setText(\"Check In Successfull\")\n                        self.reset_fields()\n                        return\n                    else:\n                        self.check_in_label.setStyleSheet(\"color: red\")\n                        self.check_in_label.setText(\n                            f\"Error checking in: {', '.join(not_updated)}\"\n                        )\n                        return\n\n            # Getting the values from the fields\n            status = self.status_dropdown.currentText()\n            note = self.note_field.toPlainText()\n            # sku = self.sku_field.text()\n            sku = self.results[self.current_result_index][0]\n            components = self.get_sku_status_layout()\n            conditions = [condition for sku, condition in components.items()]\n\n            # Making sure the status has been selected\n            if status == \"Select Status\":\n                self.check_in_label.setStyleSheet(\"color: red\")\n                self.check_in_label.setText(\"Please select a status.\")\n                return\n            # Making sure the SKU is not empty if the status is \"Wrong Part\"\n            elif status == \"Wrong Part\" and not sku:\n                self.check_in_label.setStyleSheet(\"color: red\")\n                self.check_in_label.setText(\"Please enter a SKU.\")\n                return\n            # Making sure the SKU has been verified if the status is \"Wrong Part\"\n            elif status == \"Wrong Part\" and self.sku_layout_is_not_visible():\n                self.check_in_label.setStyleSheet(\"color: red\")\n                self.check_in_label.setText(\"Please click search to verify SKU.\")\n                return\n            # Making sure if status is incomplete, there are no missing parts\n            elif status == \"Incomplete\" and \"Missing\" not in conditions:\n                self.check_in_label.setStyleSheet(\"color: red\")\n                self.check_in_label.setText(\n                    \"Can't be Incomplete. There are no missing parts.\"\n                )\n                return\n            elif status == \"Complete\" and \"Missing\" in conditions:\n                self.check_in_label.setStyleSheet(\"color: red\")\n                self.check_in_label.setText(\n                    \"Can't be Complete. There are missing parts.\"\n                )\n                return\n\n            successfull = self.db.check_in_return(\n                tracking_number, status, note, sku, components\n            )\n\n            if not successfull:\n                self.check_in_label.setStyleSheet(\"color: red\")\n                self.check_in_label.setText(\"Error checking in.\")\n                return\n\n            if self.current_tracking_number_was_checked_in and successfull:\n                self.check_in_label.setStyleSheet(\"color: green\")\n                self.check_in_label.setText(\"Updated Successfully.\")\n            elif successfull:\n                self.check_in_label.setStyleSheet(\"color: green\")\n                self.check_in_label.setText(\"Check In Successfull\")\n\n            self.reset_fields()\n            return\n\n    # Searching for a tracking number --------------------------------------------------------\n\n    def clean_fedex_tracking_number(self, tracking_number):\n        # Step 1: Remove any non-digit characters\n        cleaned_number = \"\".join(filter(str.isdigit, tracking_number))\n\n        if len(cleaned_number) > 30:\n            self.tracking_number_field.setText(cleaned_number[-12:])\n            return cleaned_number[-12:]\n        else:\n            return tracking_number\n\n    def run_search_task(self, tracking_number):\n        \"\"\"\n        This function will be run in the background. It performs the search in the database.\n        \"\"\"\n        if self.check_db_connection():\n            results = self.db.search_tracking_number(tracking_number)\n            return results\n        return None\n\n    def search_tracking_number(self):\n        # Step 1: Clean the tracking number\n        self.reset_fields(clear_tracking=False)\n        self.status_dropdown.setDisabled(False)\n        tracking_number = self.tracking_number_field.text().upper().replace(\" \", \"\")\n        tracking_number = self.clean_fedex_tracking_number(tracking_number)\n\n        self.tracking_number_field.setDisabled(True)\n        self.current_tracking_number = tracking_number\n\n        # Step 2: Set up a QTimer in the main thread to update the label\n        self.loading_step = 0  # Reset the loading step\n        self.loading_timer = QTimer(self)\n        self.loading_timer.timeout.connect(\n            lambda: self.update_loading_label(\"Searching\")\n        )\n        self.loading_timer.start(500)  # Update the label every 500ms\n\n        # Step 3: Start the LabelUpdater (worker) to run the long-running task in a background thread\n        self.label_updater = LabelUpdater(self.run_search_task, args=(tracking_number,))\n\n        # Connect the signals\n        self.label_updater.update_done.connect(self.handle_search_results)\n        self.label_updater.update_failed.connect(self.handle_search_failed)\n\n        # Start the worker thread\n        self.label_updater.start()\n\n    def update_loading_label(self, action):\n        \"\"\"\n        Update the label text with a loading message.\n        \"\"\"\n        self.check_in_label.setStyleSheet(\"color: green\")\n        dots = \".\" * (self.loading_step % 4)  # Cycle between 0 to 3 dots\n        self.check_in_label.setText(f\"{action}{dots}\")\n        self.loading_step += 1\n\n    def stop_loading_animation(self):\n        \"\"\"\n        Stop the QTimer and reset the label text.\n        \"\"\"\n        if hasattr(self, \"loading_timer\"):\n            self.loading_timer.stop()\n        self.check_in_label.setText(\"\")  # Clear the label text\n\n    def handle_search_results(self, results):\n        self.stop_loading_animation()  # Stop the loading animation\n        if not results:\n            self.check_in_label.setStyleSheet(\"color: red\")\n            self.check_in_label.setText(\"Tracking Number not found.\")\n        else:\n            self.results = results\n            if len(results) > 1:\n                self.populate_pallet_list(results)\n                self.is_pallet = True\n                self.print_checklist_button.setVisible(True)\n                self.mark_selected_sku(0)\n                self.current_pallet_note = self.db.get_pallet_note(\n                    self.current_tracking_number\n                )\n                self.pallet_note_button.setVisible(True)\n\n            self.check_in_label.setText(\" \")\n\n            self.show_results()\n\n    def handle_search_failed(self, error_message):\n        self.stop_loading_animation()  # Stop the loading animation\n        self.check_in_label.setStyleSheet(\"color: red\")\n        self.check_in_label.setText(f\"Error: {error_message}\")\n\n    # Current result modifiers --------------------------------------------------------\n\n    def on_status_change(self):\n        status = self.status_dropdown.currentText()\n\n        if status == \"Wrong Part\":\n            if self.results[self.current_result_index][4] != \"Wrong Part\":\n                self.swap_parts()\n            self.update_current_status(status)\n            self.update_note(\"Wrong sku was received.\")\n            self.clear_sku_status_layout()\n\n            self.sku_field.setText(\"\")\n            self.sku_field.setDisabled(False)\n            self.search_sku_button.setVisible(True)\n\n        elif status == \"Wrong Product\":\n            if self.results[self.current_result_index][4] == \"Wrong Part\":\n                self.swap_parts()\n                self.delete_worng_parts()\n\n            self.update_current_status(status)\n            self.reset_fields(clear_tracking=False)\n            self.update_note(\"Not our product.\")\n            components = self.switch_all_conditions(\"Missing\")\n            self.update_sku_status_layout(components)\n\n        elif status == \"Select Status\":\n            if self.results[self.current_result_index][4] == \"Wrong Part\":\n                self.swap_parts()\n                self.delete_worng_parts()\n\n            self.update_current_status(status)\n            self.reset_fields(clear_tracking=False)\n\n        else:\n            if self.results[self.current_result_index][4] == \"Wrong Part\":\n                self.swap_parts()\n                self.delete_worng_parts()\n                self.switch_all_conditions(\"Good\")\n                self.reset_note_to_empty()\n\n            if self.results[self.current_result_index][4] == \"Wrong Product\":\n                self.switch_all_conditions(\"Good\")\n                self.reset_note_to_empty()\n\n            self.update_current_status(status)\n            self.reset_fields(clear_tracking=False)\n\n        self.show_results()\n\n    def switch_all_conditions(self, new_condition):\n        components = self.results[self.current_result_index][-1]\n        components = {part: new_condition for part, contition in components.items()}\n        self.update_components(components)\n        return components\n\n    def update_note(self, note):\n        results = list(self.results[self.current_result_index])\n        results[5] = note\n        self.results[self.current_result_index] = tuple(results)\n        self.note_field.setText(note)\n\n    def update_components(self, components):\n        results = list(self.results[self.current_result_index])\n        results[-1] = components\n        self.results[self.current_result_index] = tuple(results)\n\n    def update_current_status(self, new_status):\n        if self.results[self.current_result_index][4] != new_status:\n            results = list(self.results[self.current_result_index])\n            results[4] = new_status\n            self.results[self.current_result_index] = tuple(results)\n\n    def swap_parts(self):\n        reults_list = list(self.results[self.current_result_index])\n        temp = reults_list[-2]\n        reults_list[-2] = reults_list[-1]\n        reults_list[-1] = temp\n        self.results[self.current_result_index] = tuple(reults_list)\n\n    def delete_worng_parts(self):\n        results = list(self.results[self.current_result_index])\n        results[-2] = {}\n        self.results[self.current_result_index] = tuple(results)\n\n    def search_sku_button_click(self):\n        if self.check_db_connection():\n            sku = self.sku_field.text().upper()\n            self.sku_field.setText(sku)\n            components = self.db.verify_sku(sku)\n\n            if self.is_pallet and self.sku_in_pallet(sku):\n                self.check_in_label.setStyleSheet(\"color: red\")\n                self.check_in_label.setText(\"The SKU is already in the pallet.\")\n                return\n\n            if components:\n                self.check_in_label.setStyleSheet(\"color: green\")\n                self.check_in_label.setText(\"SKU found.\")\n                self.update_sku_status_layout(components)\n                components = {part: \"Good\" for part in components}\n                self.update_components(components)\n                self.sku_field.clearFocus()\n            else:\n                self.check_in_label.setStyleSheet(\"color: red\")\n                self.check_in_label.setText(\"SKU not found.\")\n                self.clear_sku_status_layout()\n\n    def sku_in_pallet(self, sku):\n        for result in self.results:\n            if sku == self.sku_cleanner(result[0]):\n                return True\n        return False\n\n    def reset_note_to_empty(self):\n        self.note_field.setText(\"\")\n        self.on_note_change()\n\n    # On changes -------------------------------------------------------------------\n    def on_parts_condition_change(self):\n        if self.results:\n            results = list(self.results[self.current_result_index])\n            if not self.do_not_update_state:\n                new_components = self.get_sku_status_layout()\n                results[-1] = new_components\n                self.results[self.current_result_index] = tuple(results)\n\n    def on_note_change(self):\n        if self.results:\n            results = list(self.results[self.current_result_index])\n            if self.status_dropdown.currentText() not in [\n                \"Wrong Product\",\n                \"Wrong Part\",\n            ]:\n                new_note = self.note_field.toPlainText()\n                results[5] = new_note\n                self.results[self.current_result_index] = tuple(results)\n\n    # Pallets -------------------------------------------------------------------\n\n    def open_pallet_note_dialog(self):\n        \"\"\"\n        Opens the pallet note dialog and returns the entered text.\n        :param initial_text: Text to pre-fill in the text field.\n        :return: The text entered in the text field or an empty string if no text is entered.\n        \"\"\"\n        app = QApplication.instance()\n        if app is None:\n            app = QApplication(sys.argv)\n\n        dialog = PalletNoteDialog(initial_text=self.current_pallet_note)\n        if dialog.exec_() == QDialog.Accepted:\n            self.current_pallet_note = dialog.get_text()\n\n    def print_checklist(self):\n        authorization_id = self.results[0][1]\n        tracking_number = self.current_tracking_number\n\n        # Step 1: Set up a QTimer in the main thread to update the label\n        self.loading_step = 0  # Reset the loading step\n        self.loading_timer = QTimer(self)\n        self.loading_timer.timeout.connect(\n            lambda: self.update_loading_label(\"Printing\")\n        )\n        self.loading_timer.start(500)  # Update the label every 500ms\n\n        # Step 2: Start the LabelUpdater (worker) to run the long-running task in a background thread\n        self.label_updater = LabelUpdater(\n            generate_and_print_pdf,\n            args=(\n                authorization_id,\n                tracking_number,\n                self.results,\n            ),\n        )\n\n        # Connect the signals\n        self.label_updater.update_done.connect(self.handle_successful_print)\n        self.label_updater.update_failed.connect(self.handle_failed_print)\n\n        # Start the worker thread\n        self.label_updater.start()\n\n    def handle_successful_print(self):\n        self.stop_loading_animation()\n        self.check_in_label.setText(\"Printed Successfully\")\n\n    def handle_failed_print(self):\n        self.stop_loading_animation()\n        self.check_in_label.setText(\"Error Printing\")\n\n    def on_sku_clicked(self, index):\n        self.check_in_label.setText(\" \")\n        if self.ready_to_click_next():\n            self.mark_selected_sku(index)\n            self.reset_fields(clear_tracking=False)\n            self.current_search_results = self.results[index]\n            self.current_result_index = index\n            self.show_results()\n\n    def mark_selected_sku(self, index):\n        # If there was a previously selected index, reset its appearance\n        if self.results:\n            selected_sku = self.results[index][0]\n            previous_sku = self.results[self.current_result_index][0]\n\n            selected_label = self.sku_selected_labels.get(selected_sku)\n            previous_label = self.sku_selected_labels.get(previous_sku)\n\n            if selected_label != previous_label:\n                selected_label.setStyleSheet(\n                    \"border: 1px solid black; background-color: white;\"\n                )\n                previous_label.setStyleSheet(\n                    \"border: 0px; background-color: ligh gray;\"\n                )\n            else:\n                selected_label.setStyleSheet(\n                    \"border: 1px solid black; background-color: white;;\"\n                )\n\n    def ready_to_click_next(self):\n        (\n            sku,\n            return_id_number,\n            expected_sku_amount,\n            sku_amount_received,\n            status,\n            note,\n            received,\n            wrong_parts,\n            components,\n        ) = self.results[self.current_result_index]\n\n        if status != \"Select Status\":\n            # Making sure the status has been selected\n            conditions = [condition for sku, condition in components.items()]\n\n            # Making sure the SKU is not empty if the status is \"Wrong Part\"\n            if status == \"Wrong Part\" and not sku:\n                self.check_in_label.setStyleSheet(\"color: red\")\n                self.check_in_label.setText(\"Please enter a SKU.\")\n                return False\n            # Making sure the SKU has been verified if the status is \"Wrong Part\"\n            elif status == \"Wrong Part\" and self.sku_layout_is_not_visible():\n                self.check_in_label.setStyleSheet(\"color: red\")\n                self.check_in_label.setText(\"Please click search to verify SKU.\")\n                return False\n            # Making sure if status is incomplete, there are no missing parts\n            elif status == \"Incomplete\" and \"Missing\" not in conditions:\n                self.check_in_label.setStyleSheet(\"color: red\")\n                self.check_in_label.setText(\n                    \"Can't be Incomplete. There are no missing parts.\"\n                )\n                return False\n            elif status == \"Complete\" and \"Missing\" in conditions:\n                self.check_in_label.setStyleSheet(\"color: red\")\n                self.check_in_label.setText(\n                    \"Can't be Complete. There are missing parts.\"\n                )\n                return False\n\n            self.update_status_label_to_green(sku)\n\n        elif status == \"Select Status\":\n            self.update_status_label_to_red(sku)\n\n        return True\n\n    def update_status_label_to_green(self, sku):\n        self.sku_status_labels[sku].setStyleSheet(\"color: green;\")\n\n    def update_status_label_to_red(self, sku):\n        self.sku_status_labels[sku].setStyleSheet(\"color: red;\")\n\n    def clear_layout(self, layout):\n        if layout is not None:\n            while layout.count():\n                child = layout.takeAt(0)\n                if child.widget() is not None:\n                    child.widget().setParent(None)\n                elif child.layout() is not None:\n                    self.clear_layout(child.layout())\n\n    def clear_pallet_list(self):\n        # Clear any existing items in the pallet layout\n        for i in reversed(range(self.pallet_layout.count())):\n            item = self.pallet_layout.itemAt(i)\n            if item is not None:\n                widget_to_remove = item.widget()\n                if widget_to_remove is not None:\n                    widget_to_remove.setParent(None)\n                else:\n                    # If the item is a layout, recursively delete its items\n                    self.clear_layout(item.layout())\n                    self.pallet_layout.removeItem(item)\n\n        # Make the pallet scroll area invisible\n        self.pallet_scroll_area.setVisible(False)\n\n    def populate_pallet_list(self, results):\n        skus = [sku for sku, _, _, _, _, _, _, _, _ in results]\n        sku_and_received = {\n            sku: received for sku, _, _, _, _, _, received, _, _ in results\n        }\n        # Clear any existing items in the pallet layout\n        self.pallet_scroll_area.setVisible(True)\n\n        for i in reversed(range(self.pallet_layout.count())):\n            widget_to_remove = self.pallet_layout.itemAt(i).widget()\n            if widget_to_remove is not None:\n                widget_to_remove.setParent(None)\n\n        self.sku_status_labels.clear()  # Clear the status labels dictionary\n        self.sku_selected_labels.clear()  # Clear the selected labels dictionary\n\n        # Populate the pallet layout with SKUs\n        for index, sku in enumerate(skus):\n            # Create a horizontal layout for each SKU\n            h_layout = QHBoxLayout()\n\n            # SKU Label with index\n            sku_label = ClickableLabel(index)\n            sku_label.setText(self.sku_cleanner(sku))\n            sku_label.setAlignment(Qt.AlignLeft)\n            sku_label.setAlignment(Qt.AlignVCenter)\n            sku_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)\n            sku_label.clicked.connect(self.on_sku_clicked)  # Connect signal\n            h_layout.addWidget(sku_label)\n\n            # Status Label\n            status_label = QLabel(\"█\")\n            status_label.setAlignment(Qt.AlignRight)\n            status_label.setAlignment(Qt.AlignVCenter)\n            if sku_and_received[sku]:\n                status_label.setStyleSheet(\"color: green;\")\n            else:\n                status_label.setStyleSheet(\"color: red;\")\n            status_label.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n            h_layout.addWidget(status_label)\n\n            # Add the horizontal layout to the pallet layout\n            self.pallet_layout.addLayout(h_layout)\n\n            # Store the status label for later updates\n            self.sku_status_labels[sku] = status_label\n            self.sku_selected_labels[sku] = sku_label\n\n    # UI manipulators -------------------------------------------------------------------\n    def sku_cleanner(self, sku):\n        sku_and_po = sku.split(\"@\")\n        return sku_and_po[0]\n\n    def clear_button_click(self):\n        self.reset_fields(True)\n\n    def show_results(self):\n        if self.results[self.current_result_index]:\n            (\n                sku,\n                return_id_number,\n                expected_sku_amount,\n                sku_amount_received,\n                status,\n                note,\n                received,\n                wrong_parts,\n                components,\n            ) = self.results[self.current_result_index]\n            if status == \"Wrong Part\":\n                sku = \"\"\n            self.status_dropdown.setCurrentText(status)\n            self.sku_field.setText(self.sku_cleanner(sku))\n            self.auth_value.setText(return_id_number)\n            self.expected_value.setText(str(expected_sku_amount))\n            self.received_value.setText(\n                f\"{sku_amount_received} out of {expected_sku_amount}\"\n            )\n            self.note_field.setText(note)\n\n            if components:\n                self.update_sku_status_layout(components)\n\n            if received:\n                self.check_in_label.setStyleSheet(\"color: green\")\n                self.check_in_label.setText(\"Tracking Number already checked in.\")\n                self.current_tracking_number_was_checked_in = True\n\n    def reset_fields(self, clear_tracking=True):\n        # Resetting Tracking Number field\n        if clear_tracking:\n            self.tracking_number_field.clear()\n            self.tracking_number_field.setDisabled(False)\n            self.status_dropdown.setCurrentIndex(0)\n            self.status_dropdown.setDisabled(True)\n            self.current_search_results = None\n            self.note_field.clear()\n            self.originally_wrong_parts = False\n            self.originally_wrong_product = False\n            self.current_tracking_number_was_checked_in = False\n            self.current_result_index = 0\n            self.clear_pallet_list()\n            self.is_pallet = False\n            self.print_checklist_button.setVisible(False)\n            self.results = None\n            self.pallet_note_button.setVisible(False)\n            self.current_pallet_note = None\n\n        # Resetting Information fields\n        self.auth_value.setText(\" \")\n        self.expected_value.setText(\" \")\n        self.received_value.setText(\" \")\n\n        # Resetting SKU fields\n        self.sku_field.clear()\n        self.sku_field.setDisabled(True)\n        self.clear_sku_status_layout()\n        self.search_sku_button.setVisible(False)\n\n        # Setting the focus back to the tracking number field to scan the next tracking number\n        self.tracking_number_field.setFocus()\n\n    def update_sku_status_layout(self, components):\n        self.do_not_update_state = True\n        # Hide all SKU widgets initially\n        for layout, label, dropdown in self.sku_widgets:\n            label.setVisible(False)\n            dropdown.setVisible(False)\n\n        # Get the list of SKUs from the components\n        sku_list = list(components.keys())\n\n        # Update and show only the widgets you need based on sku_list\n        for i, sku in enumerate(sku_list):\n            if i < len(self.sku_widgets):\n\n                layout, label, dropdown = self.sku_widgets[i]\n                contition = components[sku]\n                if contition == \"Good\":\n                    dropdown.setCurrentIndex(0)\n                elif contition == \"Damaged\":\n                    dropdown.setCurrentIndex(1)\n                elif contition == \"Missing\":\n                    dropdown.setCurrentIndex(2)\n                else:\n                    dropdown.setCurrentIndex(0)\n                label.setText(sku)  # Update SKU label\n                label.setVisible(True)  # Show the label\n                dropdown.setVisible(True)  # Show the dropdown\n\n        self.do_not_update_state = False\n\n    def get_sku_status_layout(self):\n        components = {}\n        for layout, label, dropdown in self.sku_widgets:\n            sku = label.text()\n            if sku == \"SKU\":\n                continue\n            status = dropdown.currentText()\n            if sku and status:\n                components[sku] = status\n        return components\n\n    def clear_sku_status_layout(self):\n        # Hide all SKU widgets\n        for layout, label, dropdown in self.sku_widgets:\n            label.setText(\"SKU\")\n            label.setVisible(False)\n            dropdown.setVisible(False)\n\n    def sku_layout_is_not_visible(self):\n        return not any(\n            label.isVisible() for layout, label, dropdown in self.sku_widgets\n        )\n\n    # Copying the authorization ID --------------------------------------------------------\n\n    def copy_auth_value(self):\n        # Get the text from the label\n        value = self.auth_value.text()\n\n        # Copy the value to the clipboard\n        clipboard = QApplication.clipboard()\n        clipboard.setText(value)\n\n        # self.auth_value.setToolTip(\"Copied!\")\n        self.show_tooltip()\n\n    def show_tooltip(self):\n        # Get the position for the tooltip\n        tooltip_position = self.auth_value.mapToGlobal(self.auth_value.rect().center())\n\n        # Adjust the position slightly to ensure visibility\n        screen_rect = QDesktopWidget().availableGeometry(self)\n        if tooltip_position.x() + 50 > screen_rect.right():\n            tooltip_position.setX(screen_rect.right() - 50)\n        if tooltip_position.y() + 20 > screen_rect.bottom():\n            tooltip_position.setY(screen_rect.bottom() - 20)\n\n        # Delay showing the tooltip slightly to ensure it shows\n        QTimer.singleShot(0, lambda: QToolTip.showText(tooltip_position, \"Copied!\"))\n\n    # Database connection -------------------------------------------------------------------\n\n    def check_db_connection(self):\n        if self.db.check_if_connected():\n            self.db_label.setText(\"Connected to Database\")\n            self.db_label.setStyleSheet(\"color: green\")\n            return True\n        else:\n            try:\n                self.db.reconnect()\n                self.db_label.setText(\"Connected to Database\")\n                self.db_label.setStyleSheet(\"color: green\")\n                return True\n            except Exception as e:\n                self.db_label.setText(\"Disconnected from Database\")\n                self.db_label.setStyleSheet(\"color: red\")\n                return False\n"
      }
    ],
    "repoLink": "https://github.com/aborroto1984/returns_app",
    "technologies": [
      { name: "Python", icon: `${process.env.PUBLIC_URL}/icons/python.png` },
      { name: "Azure", icon: `${process.env.PUBLIC_URL}/icons/azure.png` },
      { name: "SQL", icon: `${process.env.PUBLIC_URL}/icons/sql.png` },
      { name: "Git", icon: `${process.env.PUBLIC_URL}/icons/git.png` },
      { name: "ReportLab", icon: `${process.env.PUBLIC_URL}/icons/reportlab.webp` },
      { name: "PyQT5", icon: `${process.env.PUBLIC_URL}/icons/pyqt.png` },
    ]
  }
];